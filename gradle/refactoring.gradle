// Board-hole ìŠ¤íƒ€ì¼ ë¦¬íŒ©í† ë§ ìë™í™” íƒœìŠ¤í¬

// ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„± íƒœìŠ¤í¬
task createBoardHoleStructure {
    group = 'refactoring'
    description = 'Create board-hole style directory structure'
    
    doLast {
        def domains = ['todo', 'member', 'auth', 'category', 'challenge', 'experience', 'profile', 'level']
        def srcBase = file('src/main/java/point/ttodoApi')
        
        println "ğŸ—ï¸  Creating board-hole directory structure..."
        
        domains.each { domain ->
            def domainPath = "${srcBase}/${domain}"
            
            // Domain validation ë””ë ‰í† ë¦¬ ìƒì„±
            file("${domainPath}/domain/validation/required").mkdirs()
            file("${domainPath}/domain/validation/optional").mkdirs()
            
            // Application ì„œë¸Œë””ë ‰í† ë¦¬ ìƒì„±/í™•ì¸
            file("${domainPath}/application/command").mkdirs()
            file("${domainPath}/application/query").mkdirs()
            file("${domainPath}/application/event").mkdirs()
            file("${domainPath}/application/result").mkdirs()
            file("${domainPath}/application/mapper").mkdirs()
            
            // Presentation ê¸°ë³¸ êµ¬ì¡° í™•ì¸
            file("${domainPath}/presentation/dto").mkdirs()
            file("${domainPath}/presentation/mapper").mkdirs()
            
            println "âœ… Created structure for domain: ${domain}"
        }
        
        // Shared êµ¬ì¡° ìƒì„±
        file("${srcBase}/shared/exception").mkdirs()
        file("${srcBase}/shared/config").mkdirs()
        file("${srcBase}/shared/security").mkdirs()
        
        domains.each { domain ->
            file("${srcBase}/shared/exception/${domain}").mkdirs()
            file("${srcBase}/shared/config/${domain}").mkdirs()
        }
        
        println "âœ… Created shared structure with domain-specific subdirectories"
        println "ğŸ¯ Board-hole directory structure creation completed!"
    }
}

// íŒŒì¼ ë¬¼ë¦¬ì  ì´ë™ íƒœìŠ¤í¬
task moveFilesToBoardHoleStructure {
    group = 'refactoring'
    description = 'Move files to match board-hole structure'
    dependsOn createBoardHoleStructure
    
    doLast {
        def srcBase = file('src/main/java/point/ttodoApi')
        def moveCount = 0
        
        println "ğŸ“ Moving files to board-hole structure..."
        
        // Application layer DTOs ì´ë™
        println "ğŸ“¦ Moving application layer files..."
        
        // Command files
        fileTree(srcBase) {
            include '**/application/dto/command/*.java'
        }.each { file ->
            def targetDir = file.parentFile.parentFile.parentFile
            def commandDir = new File(targetDir, 'command')
            if (!commandDir.exists()) commandDir.mkdirs()
            
            def targetFile = new File(commandDir, file.name)
            if (file.renameTo(targetFile)) {
                println "  Moved: ${file.name} â†’ command/"
                moveCount++
            }
        }
        
        // Query files
        fileTree(srcBase) {
            include '**/application/dto/query/*.java'
        }.each { file ->
            def targetDir = file.parentFile.parentFile.parentFile
            def queryDir = new File(targetDir, 'query')
            if (!queryDir.exists()) queryDir.mkdirs()
            
            def targetFile = new File(queryDir, file.name)
            if (file.renameTo(targetFile)) {
                println "  Moved: ${file.name} â†’ query/"
                moveCount++
            }
        }
        
        // Result files
        fileTree(srcBase) {
            include '**/application/dto/result/*.java'
        }.each { file ->
            def targetDir = file.parentFile.parentFile.parentFile
            def resultDir = new File(targetDir, 'result')
            if (!resultDir.exists()) resultDir.mkdirs()
            
            def targetFile = new File(resultDir, file.name)
            if (file.renameTo(targetFile)) {
                println "  Moved: ${file.name} â†’ result/"
                moveCount++
            }
        }
        
        // Presentation DTOs í‰íƒ„í™”
        println "ğŸ¨ Flattening presentation layer files..."
        
        // Request files
        fileTree(srcBase) {
            include '**/presentation/dto/request/*.java'
        }.each { file ->
            def dtoDir = file.parentFile.parentFile
            def targetFile = new File(dtoDir, file.name)
            if (file.renameTo(targetFile)) {
                println "  Flattened: ${file.name} (request â†’ dto)"
                moveCount++
            }
        }
        
        // Response files
        fileTree(srcBase) {
            include '**/presentation/dto/response/*.java'
        }.each { file ->
            def dtoDir = file.parentFile.parentFile
            def targetFile = new File(dtoDir, file.name)
            if (file.renameTo(targetFile)) {
                println "  Flattened: ${file.name} (response â†’ dto)"
                moveCount++
            }
        }
        
        // Exception files ì´ë™
        println "âš ï¸  Moving exception files to shared..."
        
        def domains = ['todo', 'member', 'auth', 'category', 'challenge', 'experience']
        domains.each { domain ->
            def exceptionDir = new File(srcBase, "${domain}/exception")
            if (exceptionDir.exists()) {
                def sharedExceptionDir = new File(srcBase, "shared/exception/${domain}")
                if (!sharedExceptionDir.exists()) sharedExceptionDir.mkdirs()
                
                exceptionDir.listFiles()?.each { file ->
                    if (file.isFile() && file.name.endsWith('.java')) {
                        def targetFile = new File(sharedExceptionDir, file.name)
                        if (file.renameTo(targetFile)) {
                            println "  Moved exception: ${file.name} â†’ shared/exception/${domain}/"
                            moveCount++
                        }
                    }
                }
            }
        }
        
        // Config files ì´ë™
        println "âš™ï¸  Moving config files to shared..."
        
        domains.each { domain ->
            def configDir = new File(srcBase, "${domain}/config")
            if (configDir.exists()) {
                def sharedConfigDir = new File(srcBase, "shared/config/${domain}")
                if (!sharedConfigDir.exists()) sharedConfigDir.mkdirs()
                
                configDir.listFiles()?.each { file ->
                    if (file.isFile() && file.name.endsWith('.java')) {
                        def targetFile = new File(sharedConfigDir, file.name)
                        if (file.renameTo(targetFile)) {
                            println "  Moved config: ${file.name} â†’ shared/config/${domain}/"
                            moveCount++
                        }
                    } else if (file.isDirectory()) {
                        // ì„œë¸Œë””ë ‰í† ë¦¬ë„ ì²˜ë¦¬
                        def targetSubDir = new File(sharedConfigDir, file.name)
                        if (!targetSubDir.exists()) targetSubDir.mkdirs()
                        
                        file.listFiles()?.each { subFile ->
                            if (subFile.isFile() && subFile.name.endsWith('.java')) {
                                def targetFile = new File(targetSubDir, subFile.name)
                                if (subFile.renameTo(targetFile)) {
                                    println "  Moved config: ${subFile.name} â†’ shared/config/${domain}/${file.name}/"
                                    moveCount++
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Security files ì´ë™ (auth domain specific)
        def securityDir = new File(srcBase, "auth/security")
        if (securityDir.exists()) {
            def sharedSecurityDir = new File(srcBase, "shared/security")
            if (!sharedSecurityDir.exists()) sharedSecurityDir.mkdirs()
            
            securityDir.listFiles()?.each { file ->
                if (file.isFile() && file.name.endsWith('.java')) {
                    def targetFile = new File(sharedSecurityDir, file.name)
                    if (file.renameTo(targetFile)) {
                        println "  Moved security: ${file.name} â†’ shared/security/"
                        moveCount++
                    }
                } else if (file.isDirectory()) {
                    def targetSubDir = new File(sharedSecurityDir, file.name)
                    if (!targetSubDir.exists()) targetSubDir.mkdirs()
                    
                    file.listFiles()?.each { subFile ->
                        if (subFile.isFile() && subFile.name.endsWith('.java')) {
                            def targetFile = new File(targetSubDir, subFile.name)
                            if (subFile.renameTo(targetFile)) {
                                println "  Moved security: ${subFile.name} â†’ shared/security/${file.name}/"
                                moveCount++
                            }
                        }
                    }
                }
            }
        }
        
        println "ğŸ¯ File movement completed! Total files moved: ${moveCount}"
    }
}

// íŒ¨í‚¤ì§€ ì„ ì–¸ ì—…ë°ì´íŠ¸ íƒœìŠ¤í¬
task updatePackageDeclarations {
    group = 'refactoring'
    description = 'Update package declarations after moving files'
    
    doLast {
        println "ğŸ“ Updating package declarations..."
        
        def updateCount = 0
        
        // Application layer íŒ¨í‚¤ì§€ ì„ ì–¸ ì—…ë°ì´íŠ¸
        fileTree('src/main/java') {
            include '**/*.java'
        }.each { file ->
            def content = file.text
            def originalContent = content
            
            // application.dto.command â†’ application.command
            content = content.replaceAll(
                /package (.*?)\.application\.dto\.command;/,
                'package $1.application.command;'
            )
            
            // application.dto.query â†’ application.query
            content = content.replaceAll(
                /package (.*?)\.application\.dto\.query;/,
                'package $1.application.query;'
            )
            
            // application.dto.result â†’ application.result
            content = content.replaceAll(
                /package (.*?)\.application\.dto\.result;/,
                'package $1.application.result;'
            )
            
            // presentation.dto.request â†’ presentation.dto
            content = content.replaceAll(
                /package (.*?)\.presentation\.dto\.request;/,
                'package $1.presentation.dto;'
            )
            
            // presentation.dto.response â†’ presentation.dto
            content = content.replaceAll(
                /package (.*?)\.presentation\.dto\.response;/,
                'package $1.presentation.dto;'
            )
            
            // domain.exception â†’ shared.exception.domain
            content = content.replaceAll(
                /package point\.ttodoApi\.(.*?)\.exception;/,
                'package point.ttodoApi.shared.exception.$1;'
            )
            
            // domain.config â†’ shared.config.domain
            content = content.replaceAll(
                /package point\.ttodoApi\.(.*?)\.config(\..*?)?;/,
                'package point.ttodoApi.shared.config.$1$2;'
            )
            
            // auth.security â†’ shared.security
            content = content.replaceAll(
                /package point\.ttodoApi\.auth\.security(\..*?)?;/,
                'package point.ttodoApi.shared.security$1;'
            )
            
            if (content != originalContent) {
                file.text = content
                updateCount++
                println "  Updated package declaration in: ${file.name}"
            }
        }
        
        println "âœ… Package declarations updated in ${updateCount} files"
    }
}

// Import ë¬¸ ì—…ë°ì´íŠ¸ íƒœìŠ¤í¬
task updateImports {
    group = 'refactoring'
    description = 'Update import statements'
    
    doLast {
        println "ğŸ“š Updating import statements..."
        
        def updateCount = 0
        
        fileTree('src/main/java') {
            include '**/*.java'
        }.each { file ->
            def content = file.text
            def originalContent = content
            
            // application.dto.command imports
            content = content.replaceAll(
                /import (.*?)\.application\.dto\.command\.(.*?);/,
                'import $1.application.command.$2;'
            )
            
            // application.dto.query imports
            content = content.replaceAll(
                /import (.*?)\.application\.dto\.query\.(.*?);/,
                'import $1.application.query.$2;'
            )
            
            // application.dto.result imports
            content = content.replaceAll(
                /import (.*?)\.application\.dto\.result\.(.*?);/,
                'import $1.application.result.$2;'
            )
            
            // presentation.dto.request imports
            content = content.replaceAll(
                /import (.*?)\.presentation\.dto\.request\.(.*?);/,
                'import $1.presentation.dto.$2;'
            )
            
            // presentation.dto.response imports
            content = content.replaceAll(
                /import (.*?)\.presentation\.dto\.response\.(.*?);/,
                'import $1.presentation.dto.$2;'
            )
            
            // exception imports
            content = content.replaceAll(
                /import point\.ttodoApi\.(.*?)\.exception\.(.*?);/,
                'import point.ttodoApi.shared.exception.$1.$2;'
            )
            
            // config imports
            content = content.replaceAll(
                /import point\.ttodoApi\.(.*?)\.config\.(.*?);/,
                'import point.ttodoApi.shared.config.$1.$2;'
            )
            
            // security imports
            content = content.replaceAll(
                /import point\.ttodoApi\.auth\.security\.(.*?);/,
                'import point.ttodoApi.shared.security.$1;'
            )
            
            if (content != originalContent) {
                file.text = content
                updateCount++
                println "  Updated imports in: ${file.name}"
            }
        }
        
        println "âœ… Import statements updated in ${updateCount} files"
    }
}

// ë¹ˆ ë””ë ‰í† ë¦¬ ì •ë¦¬ íƒœìŠ¤í¬
task cleanEmptyDirectories {
    group = 'refactoring'
    description = 'Remove empty directories after refactoring'
    
    doLast {
        println "ğŸ§¹ Cleaning empty directories..."
        
        def removeEmptyDirs
        removeEmptyDirs = { dir ->
            if (dir.isDirectory()) {
                dir.listFiles()?.each { removeEmptyDirs(it) }
                if (dir.listFiles()?.length == 0) {
                    if (dir.delete()) {
                        println "  Removed empty directory: ${dir.name}"
                    }
                }
            }
        }
        
        removeEmptyDirs(file('src/main/java'))
        
        println "âœ… Empty directories cleaned"
    }
}

// êµ¬ì¡° ê²€ì¦ íƒœìŠ¤í¬
task validateBoardHoleStructure {
    group = 'verification'
    description = 'Validate board-hole structure compliance'
    
    doLast {
        println "ğŸ” Validating board-hole structure compliance..."
        
        def violations = []
        def warnings = []
        
        // Application layerì— dto ë””ë ‰í† ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        fileTree('src/main/java') {
            include '**/application/dto/**'
        }.each { file ->
            violations.add("âŒ DTO found in application layer: ${file.path}")
        }
        
        // Presentation layerì— request/response ì„œë¸Œë””ë ‰í† ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        fileTree('src/main/java') {
            include '**/presentation/dto/request/**'
            include '**/presentation/dto/response/**'
        }.each { file ->
            violations.add("âŒ Presentation DTOs not flattened: ${file.path}")
        }
        
        // ê°œë³„ ë„ë©”ì¸ì— exception ë””ë ‰í† ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        def domains = ['todo', 'member', 'auth', 'category', 'challenge', 'experience']
        domains.each { domain ->
            def exceptionDir = file("src/main/java/point/ttodoApi/${domain}/exception")
            if (exceptionDir.exists() && exceptionDir.listFiles()?.length > 0) {
                violations.add("âŒ Exception not moved to shared: ${domain}")
            }
        }
        
        // ê°œë³„ ë„ë©”ì¸ì— config ë””ë ‰í† ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        domains.each { domain ->
            def configDir = file("src/main/java/point/ttodoApi/${domain}/config")
            if (configDir.exists() && configDir.listFiles()?.length > 0) {
                violations.add("âŒ Config not moved to shared: ${domain}")
            }
        }
        
        // í•„ìš”í•œ ë””ë ‰í† ë¦¬ë“¤ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        def requiredDirs = [
            'shared/exception',
            'shared/config', 
            'shared/security'
        ]
        
        requiredDirs.each { dir ->
            if (!file("src/main/java/point/ttodoApi/${dir}").exists()) {
                warnings.add("âš ï¸  Missing directory: ${dir}")
            }
        }
        
        // ê²°ê³¼ ì¶œë ¥
        if (violations.empty && warnings.empty) {
            println "âœ… Structure validation passed! Board-hole compliance achieved."
        } else {
            if (!violations.empty) {
                println "\nâŒ VIOLATIONS FOUND:"
                violations.each { println "  ${it}" }
            }
            if (!warnings.empty) {
                println "\nâš ï¸  WARNINGS:"
                warnings.each { println "  ${it}" }
            }
            
            if (!violations.empty) {
                throw new GradleException("Structure validation failed! Please fix violations above.")
            }
        }
    }
}

// ì „ì²´ ë¦¬íŒ©í† ë§ ì‹¤í–‰ íƒœìŠ¤í¬
task refactorToBoardHoleStructure {
    group = 'refactoring'
    description = 'Complete refactoring to board-hole structure'
    
    dependsOn createBoardHoleStructure
    dependsOn moveFilesToBoardHoleStructure
    dependsOn updatePackageDeclarations
    dependsOn updateImports
    dependsOn cleanEmptyDirectories
    
    // íƒœìŠ¤í¬ ìˆœì„œ ë³´ì¥
    createBoardHoleStructure.finalizedBy moveFilesToBoardHoleStructure
    moveFilesToBoardHoleStructure.finalizedBy updatePackageDeclarations
    updatePackageDeclarations.finalizedBy updateImports
    updateImports.finalizedBy cleanEmptyDirectories
    
    doLast {
        println """
        ========================================
        ğŸ‰ Board-hole êµ¬ì¡° ë¦¬íŒ©í† ë§ ì™„ë£Œ!
        ========================================
        âœ… 1. ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
        âœ… 2. íŒŒì¼ ì´ë™ (application/presentation ì •ë¦¬)
        âœ… 3. íŒ¨í‚¤ì§€ ì„ ì–¸ ì—…ë°ì´íŠ¸
        âœ… 4. Import ë¬¸ ì—…ë°ì´íŠ¸
        âœ… 5. ë¹ˆ ë””ë ‰í† ë¦¬ ì •ë¦¬
        
        ğŸ“‹ ë‹¤ìŒ ë‹¨ê³„:
        1. ./gradlew rewriteRun (OpenRewriteë¡œ ì¶”ê°€ ì •ë¦¬)
        2. ./gradlew validateBoardHoleStructure (êµ¬ì¡° ê²€ì¦)
        3. ./gradlew clean build (ë¹Œë“œ ê²€ì¦)
        
        ğŸ¯ ì´ì œ ttodo-apiê°€ board-holeê³¼ ë™ì¼í•œ êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤!
        ========================================
        """
    }
}