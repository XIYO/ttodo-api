# TTODO 프로젝트 면접 대비 Q&A

## 프로젝트 개요 관련

### Q1: TTODO 프로젝트에 대해 간단히 소개해주세요.

**A:** TTODO는 개인 할 일 관리와 챌린지를 통한 동기부여를 제공하는 웹 애플리케이션입니다. 특별히 점진적 향상(Progressive Enhancement)을 적용하여 JavaScript가 비활성화된 환경에서도 기본 기능이 동작하도록 설계했습니다. 백엔드는 Spring Boot와 DDD를 기반으로, 프론트엔드는 SvelteKit으로 구축했으며, Cloudflare Workers에서 운영하여 비용 효율성을 극대화했습니다.

### Q2: 왜 프론트엔드와 백엔드를 분리했나요?

**A:** 세 가지 주요 이유가 있습니다:

1. **독립적인 배포와 확장**: 각 팀이 독립적으로 개발하고 배포할 수 있어 개발 속도가 향상됩니다.
2. **기술 스택의 유연성**: 프론트엔드는 향후 React나 Vue로 교체 가능하며, 모바일 앱도 같은 API를 사용할 수 있습니다.
3. **비용 최적화**: Cloudflare Workers의 요청 기반 과금 특성상, 클라이언트가 직접 API를 호출하면 SSR 요청을 줄여 비용을 절감할 수 있습니다.

## 아키텍처 및 설계 관련

### Q3: DDD를 적용한 이유와 장점은 무엇인가요?

**A:** DDD를 선택한 핵심 이유는 복잡한 비즈니스 로직을 체계적으로 관리하기 위해서입니다.

**장점:**
1. **도메인별 패키지 분리로 인지 부담 감소**: 개발자가 한 번에 이해해야 할 코드의 범위가 줄어듭니다.
2. **명확한 경계**: 각 도메인이 독립적이어서 팀 단위 개발 시 충돌이 최소화됩니다.
3. **확장성**: 향후 마이크로서비스로 전환 시 도메인 단위로 분리가 용이합니다.

하지만 과도한 추상화는 피하고 현실적인 타협점을 찾았습니다. 예를 들어, 완벽한 도메인 격리보다는 Common 패키지를 통해 실용적인 코드 재사용을 허용했습니다.

### Q4: 패키지 구조에서 특별히 신경 쓴 부분이 있나요?

**A:** 각 도메인 내에서 DDD의 계층 구조를 일관되게 적용했습니다:

```
domain/
├── presentation/   # Controller, Request/Response DTO
├── application/    # Service, Command/Query
├── domain/        # Entity, Value Object, Domain Service
└── infrastructure/ # Repository, External Integration
```

이 구조의 핵심은 의존성 방향입니다. Presentation → Application → Domain ← Infrastructure로 흐르며, Domain 계층은 다른 계층에 의존하지 않아 순수한 비즈니스 로직을 유지합니다.

## 기술적 구현 관련

### Q5: JWT 인증에서 RS256(RSA)를 사용한 이유는?

**A:** 대칭키 방식(HS256)과 달리 RS256은 공개키/비공개키 쌍을 사용합니다. 이로 인한 장점은:

1. **프론트엔드 자체 검증**: 공개키를 제공하여 프론트엔드가 토큰을 직접 검증할 수 있습니다.
2. **보안성**: 비공개키는 서버에만 있어 토큰 위조가 불가능합니다.
3. **신뢰성**: 프론트엔드가 JWT 페이로드의 사용자 정보를 신뢰하고 사용할 수 있습니다.

### Q6: 액세스 토큰 만료 시 처리 방식이 특별한데, 설명해주세요.

**A:** 일반적인 방식과 달리 307 리다이렉트를 활용한 자동 갱신 메커니즘을 구현했습니다:

1. 액세스 토큰 만료 감지
2. 쿠키의 리프레시 토큰으로 새 토큰 쌍 생성
3. 응답에 새 쿠키 설정 + 307 리다이렉트
4. 브라우저가 자동으로 같은 요청을 새 토큰으로 재시도

이 방식의 장점은 프론트엔드가 토큰 갱신 로직을 구현할 필요가 없다는 것입니다. 특히 SSR 환경에서도 동일하게 동작합니다.

### Q7: 쿠키와 헤더를 모두 지원하는 이유는?

**A:** 다양한 클라이언트 환경을 고려했습니다:

1. **브라우저**: 쿠키가 편리하고 HttpOnly로 보안 강화 가능
2. **모바일 앱**: Authorization 헤더가 표준적
3. **SSR**: 서버 간 통신에서는 헤더가 명시적

`MultiBearerTokenResolver`에서 우선순위를 두어 처리하며, 이를 통해 미래의 클라이언트 변경에도 유연하게 대응할 수 있습니다.

## 도전과 해결 관련

### Q8: 프로젝트에서 가장 어려웠던 기술적 도전은?

**A:** SSR과 CSR(Client-Side Rendering) 환경에서 동일한 인증 경험을 제공하는 것이 가장 도전적이었습니다.

**문제**: 
- SSR에서는 서버가 API를 호출하고 쿠키를 받음
- 이 쿠키를 브라우저에 전달해야 함
- 브라우저 직접 요청과 SSR 요청을 구분할 수 없음

**해결**:
1. SSR 서버가 받은 Set-Cookie를 그대로 브라우저에 바이패스
2. 리프레시 토큰 자동 갱신을 서버 사이드에서 처리
3. 307 리다이렉트로 투명한 토큰 갱신

### Q9: 성능 최적화를 위해 어떤 노력을 했나요?

**A:** 
1. **동적 쿼리 최적화**: JPA Criteria API로 필요한 데이터만 정확히 조회
2. **N+1 문제 해결**: Fetch Join과 Entity Graph 활용
3. **Redis 캐싱**: 리프레시 토큰과 자주 조회되는 데이터 캐싱
4. **비동기 로깅**: Log4j2 비동기 어펜더로 I/O 블로킹 최소화
5. **가상 인스턴스**: 반복 할 일은 원본만 저장하고 동적 생성

## 개선점 및 학습 관련

### Q10: 현재 프로젝트의 개선이 필요한 부분은?

**A:** 
1. **DTO 분리**: Presentation과 Application 계층의 DTO가 분리되지 않아 결합도가 높습니다.
2. **API 일관성**: 일부 엔드포인트가 RPC 스타일로 되어 있어 RESTful로 통일이 필요합니다.
3. **중복 코드**: Pageable 처리 등 반복되는 코드를 AOP로 추출할 수 있습니다.
4. **테스트 커버리지**: 도메인 로직의 단위 테스트를 더 강화해야 합니다.

이미 이런 개선점들을 인지하고 있으며, 점진적으로 리팩토링할 계획입니다.

### Q11: 이 프로젝트를 통해 배운 가장 중요한 교훈은?

**A:** "완벽한 설계보다 실용적인 설계가 중요하다"는 것입니다. 

처음에는 교과서적인 DDD를 완벽하게 구현하려 했지만, 실제로는:
- 과도한 추상화는 오히려 복잡도를 증가시킴
- 팀원들이 이해하고 유지보수할 수 있는 수준이 중요
- 비즈니스 가치를 빠르게 전달하는 것이 우선

그래서 Common 패키지를 허용하고, 일부 도메인 간 의존성도 실용적으로 처리했습니다.

## 협업 관련

### Q12: 팀 프로젝트에서 어떤 역할을 했나요?

**A:** 백엔드 리드 개발자로서:
1. **아키텍처 설계**: DDD 기반 패키지 구조 설계 및 가이드 제공
2. **인증 시스템 구축**: JWT 기반 인증 시스템 전체 구현
3. **코드 리뷰**: 팀원들의 PR 리뷰 및 피드백
4. **기술 멘토링**: JPA, Spring Security 등 기술 스택 교육

특히 도메인별로 독립적인 개발이 가능하도록 구조를 잡아, 팀원들이 병렬로 작업할 수 있게 했습니다.

### Q13: 의견 충돌이 있었다면 어떻게 해결했나요?

**A:** DTO 분리 수준에 대한 의견 차이가 있었습니다.

**상황**: 
- A안: 모든 계층에서 완전히 다른 DTO 사용
- B안: Presentation과 Application에서 일부 공유

**해결 과정**:
1. 각 방식의 장단점을 문서로 정리
2. 프로토타입으로 두 방식 모두 구현해 비교
3. 팀 회의에서 개발 속도와 유지보수성 논의
4. 초기에는 B안으로 빠르게 개발, 추후 점진적 분리로 합의

## 기술 스택 관련

### Q14: Spring Boot를 선택한 이유는?

**A:** 
1. **성숙한 생태계**: 필요한 대부분의 기능이 검증된 라이브러리로 제공
2. **팀 친숙도**: 팀원 모두 Spring 경험이 있어 학습 곡선 최소화
3. **엔터프라이즈 지원**: 보안, 트랜잭션, 캐싱 등 엔터프라이즈 기능 내장
4. **테스트 지원**: Spring Test, Mockito 등 강력한 테스트 도구

### Q15: PostgreSQL을 선택한 이유는?

**A:** 
1. **JSON 지원**: 유연한 스키마가 필요한 부분에서 JSONB 타입 활용
2. **성능**: 복잡한 쿼리와 인덱싱에서 뛰어난 성능
3. **확장성**: Partitioning, Sharding 등 확장 옵션 풍부
4. **오픈소스**: 라이선스 비용 없이 상용 환경 사용 가능

---

*이 Q&A는 실제 면접에서 나올 수 있는 질문들을 바탕으로 작성되었으며, 기술적 깊이와 실무 경험을 균형있게 보여주도록 구성했습니다.*