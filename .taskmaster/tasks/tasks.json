{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "권한 검증 시스템 구축",
        "description": "각 도메인 엔티티에 isOwn 메서드를 구현하고 SecurityService를 통해 현재 사용자 정보를 제공하여 리소스별 접근 제어를 구현합니다.",
        "status": "done",
        "dependencies": [
          "21",
          "22",
          "23"
        ],
        "priority": "high",
        "details": "1. 각 도메인 엔티티(Todo, Category, Team, Member)에 isOwn(Long memberId) 메서드 구현\n2. SecurityService 클래스 구현 - 현재 로그인한 사용자 정보 제공\n3. @PreAuthorize에서 엔티티의 isOwn 메서드 직접 호출\n4. 권한 매트릭스 정의 (ROLE_USER, ROLE_ADMIN)\n\n구현 예시:\n```java\n// 엔티티 내부\npublic class Todo {\n    public boolean isOwn(Long memberId) {\n        return this.member.getId().equals(memberId);\n    }\n}\n\n// SecurityService\n@Component\npublic class SecurityService {\n    public Long getCurrentMemberId() {\n        // SecurityContextHolder에서 현재 사용자 ID 추출\n    }\n}\n\n// 컨트롤러\n@PreAuthorize(\"#todo.isOwn(@securityService.getCurrentMemberId()) or hasRole('ADMIN')\")\npublic TodoResponse updateTodo(@PathVariable Long id, @RequestBody TodoUpdateRequest request) { }\n```",
        "testStrategy": "1. 각 엔티티의 isOwn 메서드 단위 테스트\n2. SecurityService의 getCurrentMemberId 메서드 테스트\n3. @PreAuthorize를 통한 권한 검증 통합 테스트\n4. @WithMockUser를 활용한 다양한 권한 시나리오 테스트",
        "subtasks": [
          {
            "id": 1,
            "title": "각 도메인 엔티티에 isOwn 메서드 구현",
            "description": "Todo, Category, Team, Member 등 모든 도메인 엔티티에 소유권을 확인하는 isOwn(Long memberId) 메서드를 구현합니다.",
            "status": "done",
            "dependencies": [],
            "details": "1. Todo 엔티티에 isOwn(Long memberId) 메서드 추가\n   - this.member.getId().equals(memberId) 로직 구현\n2. Category 엔티티에 isOwn 메서드 추가\n   - 카테고리 소유자 확인 로직\n3. Team 엔티티에 isOwn 메서드 추가\n   - 팀 생성자 확인 로직\n4. Member 엔티티에 isOwn 메서드 추가\n   - 본인 확인 로직 (this.getId().equals(memberId))\n5. 각 엔티티별로 null 체크 및 예외 처리 추가\n<info added on 2025-07-14T15:41:23.016Z>\n6. Category 엔티티에 canManage(Long memberId) 메서드 추가\n   - owner이거나 collaborator인 경우 true 반환\n   - this.owner.getId().equals(memberId) || this.collaborators.stream().anyMatch(collab -> collab.getMember().getId().equals(memberId))\n   - collaborator는 owner와 동일한 권한 보유\n\n7. Challenge 엔티티에 isOwner(Long memberId) 메서드 추가\n   - 챌린지 생성자 확인 로직\n   - this.owner.getId().equals(memberId)\n\n8. Challenge 엔티티에 isLeader(Long memberId) 메서드 추가\n   - 챌린지 리더 확인 로직\n   - this.leaders.stream().anyMatch(leader -> leader.getMember().getId().equals(memberId))\n\n9. Challenge 엔티티에 canManageParticipants(Long memberId) 메서드 추가\n   - owner이거나 leader인 경우 true 반환\n   - isOwner(memberId) || isLeader(memberId)\n\n10. 모든 권한 확인 메서드에 null 체크 추가\n    - memberId가 null인 경우 false 반환\n    - 관련 엔티티(owner, collaborators, leaders)가 null인 경우 적절한 처리\n</info added on 2025-07-14T15:41:23.016Z>",
            "testStrategy": "각 엔티티의 isOwn 메서드가 올바른 소유자 확인을 수행하는지 단위 테스트로 검증"
          },
          {
            "id": 2,
            "title": "SecurityService 구현 및 현재 사용자 정보 제공",
            "description": "Spring Security의 SecurityContextHolder를 활용하여 현재 로그인한 사용자 정보를 제공하는 SecurityService를 구현합니다.",
            "status": "done",
            "dependencies": [],
            "details": "1. SecurityService @Component 클래스 생성\n2. getCurrentMemberId() 메서드 구현:\n   - SecurityContextHolder.getContext().getAuthentication() 사용\n   - Principal에서 사용자 ID 추출\n   - 인증되지 않은 경우 null 반환\n3. getCurrentMember() 메서드 구현 (선택적)\n   - MemberRepository 주입하여 전체 Member 객체 반환\n4. isAuthenticated() 헬퍼 메서드 추가\n5. hasRole(String role) 메서드 추가 - 현재 사용자의 특정 권한 확인\n<info added on 2025-07-14T15:24:46.147Z>\n구현 상세 내용:\n\n1. MemberPrincipal 타입으로 Authentication 객체 캐스팅\n   - SecurityContextHolder.getContext().getAuthentication().getPrincipal()을 MemberPrincipal로 형변환\n   - ClassCastException 방지를 위한 instanceof 검증\n\n2. getCurrentMemberId() 구현 보완:\n   - Authentication이 null이 아니고 인증된 상태인지 확인\n   - Principal이 MemberPrincipal 타입인 경우에만 ID 추출\n   - 그 외의 경우 Optional.empty() 반환\n\n3. getCurrentMember() 구현:\n   - getCurrentMemberId()를 통해 ID 획득\n   - MemberRepository.findById()로 Member 엔티티 조회\n   - Optional<Member> 타입으로 반환하여 null 안전성 보장\n\n4. isAuthenticated() 구현:\n   - Authentication 객체가 존재하고 isAuthenticated()가 true인지 확인\n   - AnonymousAuthenticationToken이 아닌지 추가 검증\n\n5. MemberPrincipal 클래스 구조:\n   - UserDetails 인터페이스 구현\n   - memberId, email, authorities 필드 포함\n   - CustomUserDetailsService에서 생성하여 반환\n</info added on 2025-07-14T15:24:46.147Z>",
            "testStrategy": "MockAuthentication을 사용하여 다양한 인증 상태에서 SecurityService가 올바른 사용자 정보를 반환하는지 테스트"
          },
          {
            "id": 3,
            "title": "Team 엔티티의 멤버 권한 확인 메서드 추가",
            "description": "Team 엔티티에 팀 멤버 여부를 확인하는 추가 메서드를 구현하여 팀 리소스에 대한 세밀한 권한 관리를 지원합니다.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "1. Team 엔티티에 isMember(Long memberId) 메서드 추가:\n   - TeamMember 관계를 통해 멤버 여부 확인\n   - Stream API를 활용한 효율적인 검색\n2. hasPermission(Long memberId, TeamPermission permission) 메서드 추가:\n   - 특정 팀 내 권한 확인 (ADMIN, MEMBER 등)\n3. isOwnerOrMember(Long memberId) 복합 메서드 구현\n   - 소유자이거나 팀 멤버인 경우 true 반환\n4. TeamPermission enum 정의 (필요시)\n5. Lazy Loading 최적화를 위한 @Transactional 고려\n<info added on 2025-07-14T15:25:07.462Z>\nChallenge 엔티티에 대한 권한 확인 메서드 구현:\n1. Challenge 엔티티에 isOwner(Long memberId) 메서드 추가:\n   - createdBy 필드와 memberId 비교\n   - null 체크 포함\n2. isParticipant(Long memberId) 메서드 추가:\n   - ChallengeParticipant 관계를 통해 참가자 여부 확인\n   - Stream API를 활용한 효율적인 검색\n3. 복합 권한 확인 메서드 isOwnerOrParticipant(Long memberId) 구현\n   - 소유자이거나 참가자인 경우 true 반환\n4. Lazy Loading 최적화를 위한 @Transactional 고려\n</info added on 2025-07-14T15:25:07.462Z>",
            "testStrategy": "팀 소유자, 팀 멤버, 외부인 등 다양한 시나리오에서 권한 확인 메서드들이 올바르게 동작하는지 검증"
          },
          {
            "id": 4,
            "title": "@PreAuthorize 어노테이션 적용 및 SpEL 표현식 구성",
            "description": "모든 컨트롤러 메서드에 엔티티의 isOwn 메서드를 활용한 @PreAuthorize 어노테이션을 적용합니다.",
            "status": "done",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. TodoController의 메서드별 권한 설정:\n   - 수정/삭제: @PreAuthorize(\"#todo.isOwn(@securityService.getCurrentMemberId()) or hasRole('ADMIN')\")\n   - 조회: 공개 설정에 따른 조건부 권한\n2. CategoryController 권한 설정:\n   - @PreAuthorize(\"#category.isOwn(@securityService.getCurrentMemberId())\")\n3. TeamController 권한 설정:\n   - 팀 수정: @PreAuthorize(\"#team.isOwn(@securityService.getCurrentMemberId())\")\n   - 팀 리소스 접근: @PreAuthorize(\"#team.isMember(@securityService.getCurrentMemberId())\")\n4. MemberController 권한 설정:\n   - @PreAuthorize(\"#member.isOwn(@securityService.getCurrentMemberId())\")\n5. @EnableGlobalMethodSecurity(prePostEnabled = true) 설정 확인\n<info added on 2025-07-14T15:25:33.723Z>\n구현 방식 변경사항:\n- 컨트롤러 메서드에서 서비스 레이어 호출 후 권한 검증\n- 서비스 메서드가 엔티티를 반환하도록 하여 @PreAuthorize에서 사용\n- SpEL 표현식에서 반환된 엔티티 객체를 직접 참조\n\n서비스 레이어 구현 예시:\n```java\n// TodoService\npublic Todo findTodoForAuth(Long todoId) {\n    return todoRepository.findById(todoId)\n        .orElseThrow(() -> new TodoNotFoundException(todoId));\n}\n\n// TodoController\n@PutMapping(\"/{todoId}\")\n@PreAuthorize(\"@todoService.findTodoForAuth(#todoId).isOwn(@securityService.getCurrentMemberId()) or hasRole('ADMIN')\")\npublic ResponseEntity<TodoResponse> updateTodo(@PathVariable Long todoId, @RequestBody TodoUpdateRequest request) {\n    // 권한 검증 통과 후 실제 업데이트 로직\n}\n```\n\n각 컨트롤러별 구현 패턴:\n- CategoryController: @PreAuthorize(\"@categoryService.findCategoryForAuth(#categoryId).isOwn(@securityService.getCurrentMemberId())\")\n- TeamController: @PreAuthorize(\"@teamService.findTeamForAuth(#teamId).isOwn(@securityService.getCurrentMemberId())\")\n- MemberController: @PreAuthorize(\"@memberService.findMemberForAuth(#memberId).isOwn(@securityService.getCurrentMemberId())\")\n</info added on 2025-07-14T15:25:33.723Z>\n<info added on 2025-07-14T15:41:57.002Z>\n새로운 권한 체계 반영사항:\n\nTodoController의 카테고리 기반 Todo 수정 권한:\n- 카테고리 내 Todo 생성: @PreAuthorize(\"@categoryService.findCategoryForAuth(#categoryId).canManage(@securityService.getCurrentMemberId())\")\n- 카테고리 Todo 수정: @PreAuthorize(\"@todoService.findTodoForAuth(#todoId).category.canManage(@securityService.getCurrentMemberId()) or hasRole('ADMIN')\")\n- 카테고리 Todo 삭제: @PreAuthorize(\"@todoService.findTodoForAuth(#todoId).category.canManage(@securityService.getCurrentMemberId()) or hasRole('ADMIN')\")\n\nChallengeController의 참여자 관리 권한:\n- 참여자 초대: @PreAuthorize(\"@challengeService.findChallengeForAuth(#challengeId).canManageParticipants(@securityService.getCurrentMemberId())\")\n- 참여자 추방: @PreAuthorize(\"@challengeService.findChallengeForAuth(#challengeId).canManageParticipants(@securityService.getCurrentMemberId())\")\n- Leader 지정: @PreAuthorize(\"@challengeService.findChallengeForAuth(#challengeId).isOwn(@securityService.getCurrentMemberId())\")\n- Leader 해제: @PreAuthorize(\"@challengeService.findChallengeForAuth(#challengeId).isOwn(@securityService.getCurrentMemberId())\")\n\nChallengeTodoController의 일반 참여자 권한:\n- ChallengeTodo 완료: @PreAuthorize(\"@challengeTodoService.findChallengeTodoForAuth(#todoId).challenge.isParticipant(@securityService.getCurrentMemberId())\")\n- ChallengeTodo 생성/수정/삭제: @PreAuthorize(\"@challengeTodoService.findChallengeTodoForAuth(#todoId).challenge.canManageParticipants(@securityService.getCurrentMemberId())\")\n\n권한 분리 구현:\n- canManage(): 카테고리 owner + collaborator 권한 (Todo CRUD 가능)\n- canManageParticipants(): 챌린지 owner + leader 권한 (참여자 관리 가능)\n- isParticipant(): 일반 참여자 권한 (ChallengeTodo 완료만 가능)\n</info added on 2025-07-14T15:41:57.002Z>",
            "testStrategy": "MockMvc와 @WithMockUser를 사용하여 각 엔드포인트의 권한 검증이 올바르게 동작하는지 통합 테스트"
          },
          {
            "id": 5,
            "title": "권한 시스템 문서화 및 예외 처리 구현",
            "description": "전체 권한 시스템의 동작 방식을 문서화하고, 권한 검증 실패 시 적절한 예외 처리를 구현합니다.",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "1. 권한 매트릭스 문서 작성:\n   - 각 엔드포인트별 필요 권한 명시\n   - 엔티티별 isOwn 메서드 동작 설명\n   - SpEL 표현식 사용 예제\n2. AccessDeniedException 핸들링:\n   - @ExceptionHandler로 403 Forbidden 응답 처리\n   - 상세한 에러 메시지 제공 (개발 환경)\n3. 권한 검증 실패 로깅 추가\n4. SecurityTestUtils 클래스 작성:\n   - 테스트용 인증 객체 생성 헬퍼\n   - 다양한 권한 시나리오 생성 메서드\n5. README.md에 권한 시스템 사용 가이드 추가",
            "testStrategy": "전체 권한 시스템의 엔드투엔드 테스트 및 예외 처리 동작 검증"
          }
        ]
      },
      {
        "id": 12,
        "title": "입력값 검증 어노테이션 및 유틸리티 구축",
        "description": "커스텀 검증 어노테이션과 XSS 방지를 위한 sanitization 유틸리티를 구현합니다.",
        "details": "1. 커스텀 어노테이션 구현:\n   - @StrongPassword (패스워드 강도 검증)\n   - @SafeHtml (XSS 방지)\n   - @ValidNickname (닉네임 검증)\n   - @ValidHexColor (색상 코드 검증)\n\n2. ValidationUtils 클래스 구현:\n```java\n@Component\npublic class ValidationUtils {\n    private static final PolicyFactory POLICY = Sanitizers.FORMATTING.and(Sanitizers.LINKS);\n    \n    public String sanitizeHtml(String input) {\n        return POLICY.sanitize(input);\n    }\n}\n```\n\n3. OWASP Java HTML Sanitizer 통합",
        "testStrategy": "1. 각 커스텀 어노테이션별 유효/무효 케이스 테스트\n2. XSS 공격 패턴 필터링 테스트\n3. 경계값 테스트 (최소/최대 길이, 특수문자 등)\n4. ConstraintValidator 구현 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "OWASP Java HTML Sanitizer 의존성 추가 및 기본 설정",
            "description": "XSS 방지를 위한 OWASP Java HTML Sanitizer 라이브러리를 프로젝트에 추가하고 기본 정책을 설정합니다.",
            "dependencies": [],
            "details": "1. build.gradle에 의존성 추가:\n   implementation 'com.googlecode.owasp-java-html-sanitizer:owasp-java-html-sanitizer:20220608.1'\n\n2. SanitizationPolicy 클래스 생성:\n   - 기본 정책: FORMATTING + LINKS\n   - 추가 정책: BLOCKS, IMAGES (필요시)\n   - 커스텀 정책 정의 (허용할 태그, 속성 설정)\n\n3. 정책 종류별 상수 정의:\n   - BASIC_POLICY: 기본 텍스트 포맷팅\n   - COMMENT_POLICY: 댓글용 (링크 포함)\n   - CONTENT_POLICY: 본문용 (이미지, 테이블 포함)",
            "status": "done",
            "testStrategy": "1. 각 정책별 XSS 패턴 필터링 테스트\n2. 허용된 HTML 태그 유지 확인\n3. 악성 스크립트 제거 검증"
          },
          {
            "id": 2,
            "title": "ValidationUtils 컴포넌트 구현",
            "description": "HTML sanitization과 공통 검증 로직을 제공하는 ValidationUtils 클래스를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "1. ValidationUtils 클래스 구현:\n```java\n@Component\n@Slf4j\npublic class ValidationUtils {\n    private final PolicyFactory basicPolicy;\n    private final PolicyFactory commentPolicy;\n    private final PolicyFactory contentPolicy;\n    \n    public ValidationUtils() {\n        this.basicPolicy = Sanitizers.FORMATTING;\n        this.commentPolicy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);\n        this.contentPolicy = new HtmlPolicyBuilder()\n            .allowElements(\"p\", \"br\", \"strong\", \"em\", \"u\", \"ol\", \"ul\", \"li\")\n            .allowElements(\"a\").allowAttributes(\"href\").onElements(\"a\")\n            .allowElements(\"img\").allowAttributes(\"src\", \"alt\").onElements(\"img\")\n            .toFactory();\n    }\n    \n    public String sanitizeBasic(String input) { ... }\n    public String sanitizeComment(String input) { ... }\n    public String sanitizeContent(String input) { ... }\n    \n    // 추가 유틸리티 메서드\n    public boolean isValidHexColor(String color) { ... }\n    public boolean isStrongPassword(String password) { ... }\n    public boolean isValidNickname(String nickname) { ... }\n}```\n\n2. 각 메서드별 null 체크 및 예외 처리\n3. 로깅 추가 (sanitization 전/후 비교)",
            "status": "done",
            "testStrategy": "1. null/empty 입력 처리 테스트\n2. 각 sanitize 메서드별 XSS 패턴 테스트\n3. 유효성 검증 메서드 경계값 테스트"
          },
          {
            "id": 3,
            "title": "커스텀 검증 어노테이션 인터페이스 정의",
            "description": "@StrongPassword, @SafeHtml, @ValidNickname, @ValidHexColor 어노테이션을 정의합니다.",
            "dependencies": [],
            "details": "1. @StrongPassword 어노테이션:\n```java\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = StrongPasswordValidator.class)\npublic @interface StrongPassword {\n    String message() default \"비밀번호는 8자 이상, 대소문자, 숫자, 특수문자를 포함해야 합니다\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n    int minLength() default 8;\n    boolean requireUppercase() default true;\n    boolean requireLowercase() default true;\n    boolean requireDigit() default true;\n    boolean requireSpecialChar() default true;\n}```\n\n2. @SafeHtml 어노테이션:\n```java\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = SafeHtmlValidator.class)\npublic @interface SafeHtml {\n    String message() default \"허용되지 않은 HTML 태그가 포함되어 있습니다\";\n    SanitizationType type() default SanitizationType.BASIC;\n    enum SanitizationType { BASIC, COMMENT, CONTENT }\n}```\n\n3. @ValidNickname, @ValidHexColor 어노테이션도 동일한 패턴으로 구현",
            "status": "done",
            "testStrategy": "1. 어노테이션 메타데이터 검증\n2. 기본값 설정 확인\n3. 커스텀 메시지 적용 테스트"
          },
          {
            "id": 4,
            "title": "ConstraintValidator 구현체 개발",
            "description": "각 커스텀 어노테이션에 대한 ConstraintValidator 구현체를 개발합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. StrongPasswordValidator 구현:\n```java\n@Component\npublic class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {\n    private final ValidationUtils validationUtils;\n    private StrongPassword annotation;\n    \n    public void initialize(StrongPassword annotation) {\n        this.annotation = annotation;\n    }\n    \n    public boolean isValid(String password, ConstraintValidatorContext context) {\n        if (password == null) return false;\n        \n        boolean valid = password.length() >= annotation.minLength();\n        if (annotation.requireUppercase()) {\n            valid &= password.matches(\".*[A-Z].*\");\n        }\n        // 추가 검증 로직...\n        \n        if (!valid) {\n            context.disableDefaultConstraintViolation();\n            context.buildConstraintViolationWithTemplate(buildMessage())\n                   .addConstraintViolation();\n        }\n        return valid;\n    }\n}```\n\n2. SafeHtmlValidator 구현:\n   - ValidationUtils의 sanitize 메서드 활용\n   - 원본과 sanitized 결과 비교\n   - 차이가 있으면 유효하지 않은 것으로 판단\n\n3. ValidNicknameValidator:\n   - 한글, 영문, 숫자만 허용\n   - 길이 제한 (2-20자)\n   - 금지어 체크\n\n4. ValidHexColorValidator:\n   - #으로 시작하는 6자리 16진수 검증\n   - 3자리 축약형도 지원",
            "status": "done",
            "testStrategy": "1. 각 Validator별 유효/무효 케이스 테스트\n2. null 입력 처리 확인\n3. 커스텀 에러 메시지 생성 테스트"
          },
          {
            "id": 5,
            "title": "DTO 클래스에 어노테이션 적용 및 통합 테스트",
            "description": "구현된 검증 어노테이션을 실제 DTO 클래스에 적용하고 통합 테스트를 수행합니다.",
            "dependencies": [
              4
            ],
            "details": "1. 주요 DTO에 어노테이션 적용:\n```java\n// SignUpRequest.java\npublic class SignUpRequest {\n    @NotBlank\n    @Email\n    private String email;\n    \n    @StrongPassword\n    private String password;\n    \n    @ValidNickname\n    private String nickname;\n}\n\n// TodoCreateRequest.java\npublic class TodoCreateRequest {\n    @NotBlank\n    @SafeHtml(type = SanitizationType.BASIC)\n    private String title;\n    \n    @SafeHtml(type = SanitizationType.CONTENT)\n    private String description;\n    \n    @ValidHexColor\n    private String backgroundColor;\n}\n\n// CommentCreateRequest.java\npublic class CommentCreateRequest {\n    @NotBlank\n    @SafeHtml(type = SanitizationType.COMMENT)\n    private String content;\n}```\n\n2. GlobalExceptionHandler 확장:\n   - ConstraintViolationException 처리\n   - 검증 실패 시 상세한 에러 응답 생성\n\n3. 테스트용 TestDataBuilder 생성:\n   - 유효한 데이터 생성 헬퍼\n   - 무효한 데이터 생성 헬퍼",
            "status": "done",
            "testStrategy": "1. MockMvc를 이용한 Controller 통합 테스트\n2. 각 엔드포인트별 유효/무효 요청 테스트\n3. 에러 응답 형식 검증\n4. XSS 공격 시나리오 테스트"
          }
        ]
      },
      {
        "id": 13,
        "title": "에러 처리 체계 구축",
        "description": "RFC 7807 Problem Details 표준을 준수하는 일관된 에러 처리 체계를 구축합니다.",
        "details": "1. ProblemDetail 응답 클래스 구현\n2. 도메인별 예외 클래스 정의:\n   - BusinessException (추상 클래스)\n   - MemberNotFoundException\n   - DuplicateEmailException\n   - InvalidPasswordException 등\n\n3. 에러 코드 enum 정의:\n```java\n@Getter\n@AllArgsConstructor\npublic enum ErrorCode {\n    AUTH_001(\"인증 실패\", HttpStatus.UNAUTHORIZED),\n    AUTH_002(\"권한 부족\", HttpStatus.FORBIDDEN),\n    MEMBER_001(\"회원 정보 없음\", HttpStatus.NOT_FOUND);\n    \n    private final String message;\n    private final HttpStatus status;\n}\n```\n\n4. GlobalExceptionHandler 구현 (@RestControllerAdvice)",
        "testStrategy": "1. 각 예외 타입별 응답 형식 테스트\n2. HTTP 상태 코드 매핑 테스트\n3. 에러 메시지 국제화 테스트\n4. 예외 체인 처리 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "ProblemDetail 응답 클래스 및 에러 코드 체계 구현",
            "description": "RFC 7807 Problem Details 표준을 준수하는 응답 클래스와 도메인별 에러 코드 enum을 구현합니다.",
            "dependencies": [],
            "details": "1. ProblemDetail 응답 DTO 클래스 구현:\n- type: 문제 유형을 식별하는 URI\n- title: 문제에 대한 간단한 제목\n- status: HTTP 상태 코드\n- detail: 문제에 대한 상세 설명\n- instance: 문제가 발생한 구체적인 위치\n- timestamp: 발생 시간\n- traceId: 추적용 ID\n\n2. ErrorCode enum 구현:\n- 도메인별로 에러 코드 분류 (AUTH_, MEMBER_, TODO_, CHALLENGE_ 등)\n- 각 에러 코드에 메시지, HTTP 상태 코드, 에러 타입 포함\n- getMessage() 메서드로 국제화 지원 준비",
            "status": "done",
            "testStrategy": "ErrorCode enum의 각 값이 올바른 HTTP 상태 코드와 메시지를 반환하는지 테스트, ProblemDetail 객체가 RFC 7807 스펙에 맞게 직렬화되는지 검증"
          },
          {
            "id": 2,
            "title": "비즈니스 예외 클래스 계층 구조 구현",
            "description": "BusinessException 추상 클래스를 기반으로 도메인별 구체적인 예외 클래스들을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "1. BusinessException 추상 클래스 구현:\n- ErrorCode를 필드로 가짐\n- 생성자에서 ErrorCode 받아서 message 설정\n- getErrorCode(), getHttpStatus() 메서드 제공\n\n2. 도메인별 예외 클래스 구현:\n- MemberNotFoundException: 회원 조회 실패\n- DuplicateEmailException: 이메일 중복\n- InvalidPasswordException: 비밀번호 규칙 위반\n- UnauthorizedException: 인증 실패\n- ForbiddenException: 권한 부족\n- TodoNotFoundException: 할 일 조회 실패\n- ChallengeNotFoundException: 챌린지 조회 실패\n\n3. 각 예외 클래스는 적절한 ErrorCode를 부모 생성자에 전달",
            "status": "done",
            "testStrategy": "각 예외 클래스가 올바른 ErrorCode를 가지고 있는지, getMessage()가 적절한 메시지를 반환하는지 단위 테스트"
          },
          {
            "id": 3,
            "title": "GlobalExceptionHandler 구현",
            "description": "@RestControllerAdvice를 사용하여 전역 예외 처리기를 구현하고 RFC 7807 형식으로 응답을 반환합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. GlobalExceptionHandler 클래스 구현:\n- @RestControllerAdvice 어노테이션 적용\n- @Slf4j로 로깅 활성화\n\n2. 예외 처리 메서드 구현:\n- @ExceptionHandler(BusinessException.class): 비즈니스 예외 처리\n- @ExceptionHandler(MethodArgumentNotValidException.class): 유효성 검증 실패 처리\n- @ExceptionHandler(BindException.class): 바인딩 오류 처리\n- @ExceptionHandler(HttpMessageNotReadableException.class): 요청 본문 파싱 오류\n- @ExceptionHandler(Exception.class): 예상치 못한 서버 오류 처리\n\n3. 각 핸들러는 ProblemDetail 객체를 생성하여 ResponseEntity로 반환\n4. traceId 생성 및 로깅 구현",
            "status": "done",
            "testStrategy": "MockMvc를 사용하여 각 예외 타입별로 올바른 HTTP 상태 코드와 응답 형식이 반환되는지 통합 테스트"
          },
          {
            "id": 4,
            "title": "유효성 검증 실패 에러 처리 강화",
            "description": "Bean Validation 실패 시 필드별 상세 에러 정보를 포함한 응답을 생성합니다.",
            "dependencies": [
              3
            ],
            "details": "1. ValidationErrorDetail 클래스 구현:\n- field: 검증 실패한 필드명\n- value: 입력된 값\n- reason: 실패 이유\n\n2. ProblemDetail 클래스에 violations 필드 추가:\n- List<ValidationErrorDetail> 타입\n- 유효성 검증 실패 시에만 포함\n\n3. GlobalExceptionHandler의 validation 관련 핸들러 개선:\n- FieldError 정보를 ValidationErrorDetail로 변환\n- 여러 필드의 검증 실패를 모두 수집하여 한 번에 반환\n- @Valid, @Validated 어노테이션 처리 지원\n\n4. 커스텀 유효성 검증 어노테이션의 에러 메시지 통합",
            "status": "done",
            "testStrategy": "여러 필드가 동시에 검증 실패할 때 모든 에러 정보가 violations 배열에 포함되는지 테스트, 중첩된 객체의 검증 실패도 올바르게 처리되는지 확인"
          },
          {
            "id": 5,
            "title": "에러 로깅 및 모니터링 체계 구축",
            "description": "예외 발생 시 적절한 로깅과 추적을 위한 메커니즘을 구현합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. TraceIdGenerator 유틸리티 구현:\n- UUID 기반의 고유한 추적 ID 생성\n- MDC(Mapped Diagnostic Context)에 traceId 저장\n\n2. 로깅 전략 구현:\n- BusinessException: WARN 레벨로 로깅\n- ValidationException: INFO 레벨로 로깅\n- 서버 오류(500): ERROR 레벨로 스택트레이스와 함께 로깅\n\n3. 에러 응답에 traceId 포함:\n- 클라이언트가 문제 보고 시 참조할 수 있도록\n- 로그 검색 시 해당 요청 추적 가능\n\n4. AOP를 활용한 컨트롤러 진입점 로깅:\n- 요청 시작 시 traceId 생성 및 MDC 설정\n- 요청 완료 시 MDC 정리",
            "status": "done",
            "testStrategy": "로그 출력을 캡처하여 적절한 레벨과 포맷으로 로깅되는지 확인, traceId가 응답과 로그에 동일하게 포함되는지 검증"
          }
        ]
      },
      {
        "id": 14,
        "title": "AuthController 검증 강화",
        "description": "회원가입/로그인 API의 이메일, 패스워드, 닉네임 검증을 강화합니다.",
        "details": "1. SignUpRequest DTO 검증 강화:\n```java\npublic class SignUpRequest {\n    @Email(regexp = \"^[A-Za-z0-9+_.-]+@(.+)$\") // RFC 5322\n    private String email;\n    \n    @StrongPassword\n    @Size(min = 8, max = 100)\n    private String password;\n    \n    @ValidNickname\n    @Size(min = 2, max = 20)\n    private String nickname;\n}\n```\n\n2. 패스워드 강도 검증 규칙:\n   - 대소문자, 숫자, 특수문자 포함\n   - 연속된 문자/숫자 3개 이상 금지\n   - 일반적인 패스워드 패턴 차단\n\n3. 닉네임 금지어 필터링 구현",
        "testStrategy": "1. 유효한 이메일/패스워드/닉네임 조합 테스트\n2. 각 필드별 검증 실패 케이스 테스트\n3. 금지어 필터링 테스트\n4. 통합 테스트 (MockMvc)",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "StrongPassword 커스텀 어노테이션 및 검증 로직 구현",
            "description": "패스워드 강도를 검증하는 @StrongPassword 어노테이션과 ConstraintValidator를 구현합니다. 대소문자, 숫자, 특수문자 포함 여부 및 연속된 문자/숫자 패턴을 검사합니다.",
            "dependencies": [],
            "details": "1. @StrongPassword 어노테이션 생성:\n- @Constraint(validatedBy = StrongPasswordValidator.class) 지정\n- 기본 에러 메시지 정의\n\n2. StrongPasswordValidator 구현:\n- 최소 8자, 최대 100자 검증\n- 정규식으로 대문자, 소문자, 숫자, 특수문자 포함 검증\n- 연속된 문자(abc, 123) 3개 이상 패턴 검출\n- 일반적인 취약 패스워드 목록(password123, admin123 등) 차단\n\n3. ValidationMessages.properties에 에러 메시지 정의",
            "status": "done",
            "testStrategy": "1. 유효한 패스워드 케이스: Abc123!@#, P@ssw0rd!\n2. 실패 케이스: password(특수문자 없음), 12345678(문자 없음), abc123def(연속 패턴)\n3. 경계값 테스트: 7자(너무 짧음), 101자(너무 긺)"
          },
          {
            "id": 2,
            "title": "ValidNickname 어노테이션 및 금지어 필터링 구현",
            "description": "닉네임 유효성을 검증하는 @ValidNickname 어노테이션과 금지어 필터링 시스템을 구현합니다. 부적절한 단어나 특수문자를 차단합니다.",
            "dependencies": [],
            "details": "1. @ValidNickname 어노테이션 생성:\n- @Constraint(validatedBy = ValidNicknameValidator.class) 지정\n\n2. ValidNicknameValidator 구현:\n- 한글, 영문, 숫자만 허용 (특수문자 금지)\n- 금지어 목록 관리 (properties 파일 또는 DB)\n- 대소문자 구분 없이 금지어 포함 여부 검사\n- 공백 및 연속 공백 처리\n\n3. ForbiddenWordService 구현:\n- 금지어 목록 로드 및 캐싱\n- contains 검사 로직 (부분 일치도 차단)",
            "status": "done",
            "testStrategy": "1. 유효한 닉네임: 홍길동, user123, 테스트유저\n2. 금지어 포함: admin, root, 욕설포함닉네임\n3. 특수문자 포함: user@123, nick!name\n4. 길이 검증: 1자(너무 짧음), 21자(너무 긺)"
          },
          {
            "id": 3,
            "title": "이메일 검증 정규식 고도화 및 도메인 검증",
            "description": "RFC 5322 표준에 맞는 이메일 정규식을 적용하고, 추가적으로 일회용 이메일 도메인 차단 기능을 구현합니다.",
            "dependencies": [],
            "details": "1. EmailValidator 커스텀 구현:\n- @Email 어노테이션 기본 동작 확장\n- RFC 5322 정규식 적용\n- 로컬 파트: 영문, 숫자, 특수문자(._-+) 허용\n- 도메인 파트: 유효한 도메인 형식 검증\n\n2. 일회용 이메일 도메인 차단:\n- 차단할 도메인 목록 관리 (10minutemail.com 등)\n- 도메인 검증 시 차단 목록 체크\n\n3. 이메일 형식 정규화:\n- 소문자 변환\n- 공백 제거",
            "status": "done",
            "testStrategy": "1. 유효한 이메일: user@example.com, test.user+tag@company.co.kr\n2. 무효한 형식: @example.com, user@, user@@example.com\n3. 차단 도메인: user@10minutemail.com\n4. 특수 케이스: 한글@도메인.com (차단)"
          },
          {
            "id": 4,
            "title": "SignUpRequest/LoginRequest DTO 검증 통합 및 에러 응답 표준화",
            "description": "회원가입과 로그인 DTO에 구현한 검증 어노테이션들을 적용하고, 검증 실패 시 일관된 에러 응답 형식을 제공합니다.",
            "dependencies": [],
            "details": "1. SignUpRequest DTO 업데이트:\n```java\npublic class SignUpRequest {\n    @Email(regexp = \"^[A-Za-z0-9+_.-]+@(.+)$\")\n    @ValidEmail // 커스텀 검증 추가\n    private String email;\n    \n    @StrongPassword\n    @Size(min = 8, max = 100)\n    private String password;\n    \n    @ValidNickname\n    @Size(min = 2, max = 20)\n    private String nickname;\n}\n```\n\n2. ValidationErrorResponse 구조화:\n- 필드별 에러 메시지 매핑\n- 에러 코드 표준화\n\n3. @RestControllerAdvice에서 MethodArgumentNotValidException 처리",
            "status": "done",
            "testStrategy": "1. 전체 유효성 검증 성공 케이스\n2. 각 필드별 단일 검증 실패\n3. 복수 필드 동시 검증 실패\n4. 에러 응답 형식 일관성 확인"
          },
          {
            "id": 5,
            "title": "AuthController 통합 테스트 및 검증 문서화",
            "description": "MockMvc를 사용한 AuthController 통합 테스트를 작성하고, 검증 규칙과 에러 코드를 API 문서에 반영합니다.",
            "dependencies": [],
            "details": "1. AuthControllerTest 통합 테스트:\n- @WebMvcTest(AuthController.class) 설정\n- 정상 회원가입/로그인 시나리오\n- 각 검증 규칙별 실패 시나리오\n- 에러 응답 형식 검증\n\n2. API 문서 업데이트:\n- Swagger/OpenAPI 어노테이션 추가\n- 각 필드의 검증 규칙 명시\n- 에러 코드 및 메시지 예시\n\n3. 검증 규칙 문서:\n- 패스워드 정책 명시\n- 닉네임 규칙 및 금지어 정책\n- 이메일 형식 요구사항",
            "status": "done",
            "testStrategy": "1. MockMvc 통합 테스트 전체 실행\n2. 테스트 커버리지 90% 이상 확인\n3. API 문서 생성 및 검증\n4. 실제 API 호출 테스트 (Postman/curl)"
          }
        ]
      },
      {
        "id": 15,
        "title": "파일 업로드 보안 검증",
        "description": "프로필 이미지 업로드 시 파일 형식, 크기, 파일명 검증을 구현합니다.",
        "details": "1. FileValidationService 구현:\n```java\n@Service\npublic class FileValidationService {\n    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n    private static final Set<String> ALLOWED_EXTENSIONS = Set.of(\"jpg\", \"jpeg\", \"png\", \"gif\");\n    \n    public void validateFile(MultipartFile file) {\n        // Magic number 검증\n        // 파일 크기 검증\n        // 파일명 sanitization\n    }\n}\n```\n\n2. 파일 내용 검증 (Magic Number):\n   - JPEG: FF D8 FF\n   - PNG: 89 50 4E 47\n   - GIF: 47 49 46\n\n3. 파일명 sanitization (특수문자, 경로 탐색 방지)",
        "testStrategy": "1. 허용된 파일 형식 업로드 테스트\n2. 악의적인 파일 차단 테스트 (위장된 확장자)\n3. 파일 크기 제한 테스트\n4. 파일명 sanitization 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "JPA Criteria API 기반 동적 쿼리 구현",
        "description": "SQL Injection 방지를 위한 안전한 동적 쿼리 시스템을 구현합니다.",
        "details": "1. BaseSpecification 클래스 구현:\n```java\npublic abstract class BaseSpecification<T> {\n    protected Specification<T> buildSpecification(SearchCriteria criteria) {\n        return (root, query, cb) -> {\n            List<Predicate> predicates = new ArrayList<>();\n            // 안전한 동적 쿼리 구성\n            return cb.and(predicates.toArray(new Predicate[0]));\n        };\n    }\n}\n```\n\n2. 도메인별 Specification 구현:\n   - TodoSpecification\n   - MemberSpecification\n   - CategorySpecification\n\n3. 정렬 필드 화이트리스트 검증:\n```java\nprivate static final Set<String> ALLOWED_SORT_FIELDS = Set.of(\"id\", \"title\", \"createdAt\");\n```",
        "testStrategy": "1. 다양한 검색 조건 조합 테스트\n2. SQL Injection 시도 차단 테스트\n3. 허용되지 않은 필드 정렬 시도 테스트\n4. 복잡한 쿼리 성능 테스트",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "BaseSpecification 추상 클래스 구현",
            "description": "모든 도메인 Specification의 기반이 되는 추상 클래스를 구현하여 공통 로직을 제공합니다.",
            "dependencies": [],
            "details": "1. BaseSpecification<T> 추상 클래스 생성\n2. buildSpecification 메소드 구현 - SearchCriteria를 받아 Specification<T> 반환\n3. 공통 메소드 구현:\n   - addLikeCondition(): LIKE 검색 조건 추가\n   - addEqualsCondition(): 동등 비교 조건 추가\n   - addRangeCondition(): 범위 검색 조건 추가\n   - addInCondition(): IN 절 조건 추가\n4. SQL Injection 방지를 위한 파라미터 바인딩 처리\n5. null/empty 값 체크 및 필터링 로직 포함",
            "status": "done",
            "testStrategy": "1. 각 조건 메소드별 단위 테스트\n2. null/empty 파라미터 처리 테스트\n3. 여러 조건 조합 테스트"
          },
          {
            "id": 2,
            "title": "도메인별 Specification 구현체 작성",
            "description": "Todo, Member, Category 각 도메인에 맞는 Specification 구현체를 작성합니다.",
            "dependencies": [
              1
            ],
            "details": "1. TodoSpecification 구현:\n   - 제목, 내용, 상태별 검색\n   - 생성일자 범위 검색\n   - 카테고리별 필터링\n2. MemberSpecification 구현:\n   - 이메일, 닉네임 검색\n   - 가입일자 범위 검색\n   - 활성/비활성 상태 필터링\n3. CategorySpecification 구현:\n   - 카테고리명 검색\n   - 상위 카테고리별 필터링\n4. 각 도메인별 허용 정렬 필드 상수 정의",
            "status": "done",
            "testStrategy": "1. 도메인별 단일 조건 검색 테스트\n2. 복합 조건 검색 테스트\n3. 정렬 조건 적용 테스트"
          },
          {
            "id": 3,
            "title": "정렬 필드 화이트리스트 검증 시스템 구현",
            "description": "동적 정렬 요청에 대한 보안 검증을 위한 화이트리스트 기반 검증 시스템을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "1. SortFieldValidator 유틸리티 클래스 구현\n2. 도메인별 허용 정렬 필드 정의:\n   - Todo: id, title, createdAt, updatedAt, status\n   - Member: id, email, nickname, createdAt\n   - Category: id, name, createdAt\n3. validateSortFields 메소드 구현:\n   - Pageable의 Sort 객체에서 필드 추출\n   - 화이트리스트와 대조 검증\n   - 미허용 필드 발견 시 InvalidSortFieldException 발생\n4. 대소문자 무시 비교 옵션 제공",
            "status": "done",
            "testStrategy": "1. 허용된 필드 정렬 성공 테스트\n2. 미허용 필드 정렬 차단 테스트\n3. SQL Injection 시도 차단 테스트"
          },
          {
            "id": 4,
            "title": "Repository 레이어 통합 및 메소드 구현",
            "description": "JpaSpecificationExecutor를 상속받은 Repository에 Specification을 활용한 메소드를 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "1. 각 Repository 인터페이스에 JpaSpecificationExecutor 상속 추가\n2. Service 레이어에 동적 쿼리 메소드 구현:\n   - findAllWithFilters(SearchCriteria criteria, Pageable pageable)\n   - countWithFilters(SearchCriteria criteria)\n3. 트랜잭션 및 읽기 전용 설정 적용\n4. 쿼리 힌트 및 페치 조인 최적화\n5. 검색 결과 DTO 매핑 처리",
            "status": "done",
            "testStrategy": "1. 다양한 검색 조건 통합 테스트\n2. 페이징 처리 정확성 테스트\n3. N+1 쿼리 발생 여부 확인"
          },
          {
            "id": 5,
            "title": "성능 최적화 및 모니터링 구현",
            "description": "동적 쿼리의 성능을 최적화하고 모니터링 체계를 구축합니다.",
            "dependencies": [
              4
            ],
            "details": "1. 쿼리 실행 계획 분석 및 인덱스 추가:\n   - 자주 사용되는 검색 필드에 인덱스 생성\n   - 복합 인덱스 전략 수립\n2. 쿼리 캐싱 전략 구현:\n   - Spring Cache를 활용한 결과 캐싱\n   - 캐시 무효화 정책 설정\n3. 쿼리 실행 시간 로깅:\n   - AOP를 활용한 실행 시간 측정\n   - Slow Query 임계값 설정 및 알림\n4. 쿼리 복잡도 제한:\n   - 최대 조건 개수 제한\n   - 조인 깊이 제한",
            "status": "done",
            "testStrategy": "1. 대용량 데이터 성능 테스트\n2. 캐시 적중률 확인\n3. 동시성 테스트\n4. 메모리 사용량 모니터링"
          }
        ]
      },
      {
        "id": 17,
        "title": "페이지네이션 및 검색 파라미터 검증",
        "description": "모든 컨트롤러의 페이징, 정렬, 검색 파라미터에 대한 일관된 검증을 구현합니다.",
        "details": "1. PageableValidator 구현:\n```java\n@Component\npublic class PageableValidator {\n    public void validate(Pageable pageable, Set<String> allowedSortFields) {\n        if (pageable.getPageSize() > 100) {\n            throw new InvalidPaginationException(\"Page size cannot exceed 100\");\n        }\n        // 정렬 필드 검증\n    }\n}\n```\n\n2. SearchRequestDto 기본 클래스:\n```java\n@Getter\n@Setter\npublic abstract class BaseSearchRequest {\n    @Min(0)\n    private int page = 0;\n    \n    @Min(1) @Max(100)\n    private int size = 20;\n    \n    @Pattern(regexp = \"^[a-zA-Z0-9,_]+$\")\n    private String sort;\n}\n```\n\n3. 컨트롤러별 검증 적용",
        "testStrategy": "1. 페이지 크기 경계값 테스트\n2. 음수 페이지 번호 차단 테스트\n3. 허용되지 않은 정렬 필드 테스트\n4. 대용량 페이지 요청 성능 테스트",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "PageableValidator 컴포넌트 구현",
            "description": "페이지네이션 파라미터를 검증하는 PageableValidator 컴포넌트를 구현합니다. 페이지 크기 제한, 허용된 정렬 필드 검증, 정렬 방향 검증 등의 기능을 포함합니다.",
            "dependencies": [],
            "details": "PageableValidator 클래스를 @Component로 생성하고, validate(Pageable pageable, Set<String> allowedSortFields) 메서드를 구현합니다. 페이지 크기가 100을 초과하면 InvalidPaginationException을 발생시키고, 정렬 필드가 allowedSortFields에 포함되지 않으면 InvalidSortFieldException을 발생시킵니다. 정렬 방향은 ASC/DESC만 허용하도록 검증합니다.",
            "status": "done",
            "testStrategy": "PageableValidatorTest를 작성하여 페이지 크기 경계값(0, 1, 100, 101), 허용/비허용 정렬 필드, null Pageable 처리 등을 테스트합니다."
          },
          {
            "id": 2,
            "title": "BaseSearchRequest DTO 클래스 구현",
            "description": "모든 검색 요청에서 공통으로 사용할 BaseSearchRequest 추상 클래스를 구현합니다. 페이지 번호, 크기, 정렬 파라미터에 대한 Bean Validation 어노테이션을 적용합니다.",
            "dependencies": [],
            "details": "BaseSearchRequest 추상 클래스에 @Min, @Max, @Pattern 등의 검증 어노테이션을 적용합니다. page는 @Min(0), size는 @Min(1) @Max(100), sort는 @Pattern(regexp = \"^[a-zA-Z0-9,_]+$\")으로 검증합니다. 기본값은 page=0, size=20으로 설정하고, toPageable() 메서드를 추가하여 Spring Pageable 객체로 변환할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": "Bean Validation 테스트를 작성하여 각 필드의 제약 조건이 올바르게 동작하는지 확인합니다. ValidatorFactory를 사용한 단위 테스트를 구성합니다."
          },
          {
            "id": 3,
            "title": "도메인별 SearchRequest DTO 구현",
            "description": "각 도메인(Todo, Category, Team, Member)별로 BaseSearchRequest를 상속받은 구체적인 SearchRequest 클래스를 구현합니다. 도메인 특화 검색 필드를 추가합니다.",
            "dependencies": [
              2
            ],
            "details": "TodoSearchRequest, CategorySearchRequest, TeamSearchRequest, MemberSearchRequest 클래스를 생성합니다. 각 클래스는 BaseSearchRequest를 상속받고, 도메인별 검색 필드(예: TodoSearchRequest의 status, priority, dueDate 등)를 추가합니다. 각 필드에 적절한 검증 어노테이션을 적용하고, getAllowedSortFields() 메서드를 구현하여 허용된 정렬 필드 목록을 반환합니다.",
            "status": "done",
            "testStrategy": "각 SearchRequest 클래스에 대한 단위 테스트를 작성하여 도메인별 검증 규칙이 올바르게 동작하는지 확인합니다."
          },
          {
            "id": 4,
            "title": "컨트롤러 레이어에 검증 적용",
            "description": "모든 컨트롤러의 검색 엔드포인트에 PageableValidator와 SearchRequest DTO를 적용합니다. @Valid 어노테이션과 함께 일관된 검증 로직을 구현합니다.",
            "dependencies": [
              1,
              3
            ],
            "details": "TodoController, CategoryController, TeamController, MemberController의 검색 메서드를 수정합니다. 기존의 Pageable 파라미터를 SearchRequest DTO로 변경하고, @Valid 어노테이션을 추가합니다. 각 컨트롤러에 PageableValidator를 주입하고, 검색 메서드 시작 부분에서 pageableValidator.validate()를 호출합니다. ControllerAdvice에서 InvalidPaginationException과 InvalidSortFieldException을 처리하는 핸들러를 추가합니다.",
            "status": "done",
            "testStrategy": "MockMvc를 사용한 통합 테스트를 작성하여 각 컨트롤러의 검증이 올바르게 동작하는지 확인합니다. 유효/무효한 파라미터로 API를 호출하고 적절한 응답을 반환하는지 테스트합니다."
          },
          {
            "id": 5,
            "title": "검색 파라미터 로깅 및 모니터링 구현",
            "description": "검색 요청에 대한 로깅을 추가하고, 잘못된 검색 파라미터 사용 패턴을 모니터링할 수 있는 기능을 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "SearchParameterAspect를 구현하여 모든 검색 요청을 로깅합니다. 요청된 페이지 크기, 정렬 필드, 검색 조건 등을 기록하고, 검증 실패 시 상세한 에러 정보를 로깅합니다. SearchMetrics 클래스를 만들어 검색 파라미터 사용 통계(평균 페이지 크기, 자주 사용되는 정렬 필드 등)를 수집합니다. 개발 환경에서는 DEBUG 레벨로, 운영 환경에서는 INFO 레벨로 로깅하도록 설정합니다.",
            "status": "done",
            "testStrategy": "AOP 테스트를 작성하여 검색 요청이 올바르게 로깅되는지 확인합니다. 로그 출력을 캡처하여 예상된 정보가 포함되어 있는지 검증합니다."
          }
        ]
      },
      {
        "id": 18,
        "title": "비즈니스 로직 검증 레이어 구현",
        "description": "서비스 레이어의 비즈니스 규칙 검증을 위한 Validator 클래스들을 구현합니다.",
        "details": "1. Validator 인터페이스 정의:\n```java\npublic interface BusinessValidator<T> {\n    void validateCreate(T entity);\n    void validateUpdate(T entity, T existing);\n    void validateDelete(T entity);\n}\n```\n\n2. 도메인별 Validator 구현:\n   - MemberValidator: 이메일/닉네임 중복 검증\n   - TodoValidator: 우선순위(1-5), 반복 설정 검증\n   - CategoryValidator: 색상 코드, 이름 중복 검증\n   - ChallengeValidator: 기간, 참여자 검증\n\n3. 검증 실패 시 적절한 BusinessException 발생",
        "testStrategy": "1. 각 도메인별 생성/수정/삭제 검증 테스트\n2. 중복 데이터 검증 테스트\n3. 비즈니스 규칙 위반 케이스 테스트\n4. 트랜잭션 롤백 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Log4j2 기반 구조화된 로깅 시스템 구축",
        "description": "감사 로그와 에러 추적을 위한 구조화된 로깅 시스템을 구현합니다.",
        "details": "1. log4j2.xml 설정:\n```xml\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JsonLayout compact=\"true\" eventEol=\"true\"/>\n        </Console>\n    </Appenders>\n</Configuration>\n```\n\n2. AuditLogService 구현:\n```java\n@Service\n@Slf4j\npublic class AuditLogService {\n    public void logUserAction(String action, String resource, Long resourceId) {\n        MDC.put(\"userId\", getCurrentUserId());\n        MDC.put(\"action\", action);\n        MDC.put(\"resource\", resource);\n        log.info(\"User action executed\");\n    }\n}\n```\n\n3. 주요 이벤트 로깅:\n   - 로그인/로그아웃\n   - CRUD 작업\n   - 권한 검증 실패\n   - 예외 발생",
        "testStrategy": "1. 로그 출력 형식 검증\n2. MDC 컨텍스트 전파 테스트\n3. 로그 레벨별 필터링 테스트\n4. 성능 영향 측정",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "통합 테스트 및 문서화",
        "description": "전체 검증 시스템에 대한 통합 테스트와 API 문서를 작성합니다.",
        "details": "1. 통합 테스트 시나리오:\n   - 엔드투엔드 시나리오 테스트\n   - 보안 취약점 스캔 (OWASP ZAP)\n   - 부하 테스트 (JMeter)\n\n2. API 문서 업데이트:\n   - OpenAPI 3.0 스펙 업데이트\n   - 에러 코드 목록 문서화\n   - 검증 규칙 명세\n\n3. 개발자 가이드:\n   - 커스텀 검증 어노테이션 사용법\n   - 예외 처리 가이드라인\n   - 보안 체크리스트",
        "testStrategy": "1. 전체 API 엔드포인트 커버리지 100% 달성\n2. 다양한 에러 시나리오 재현 테스트\n3. 동시성 및 트랜잭션 테스트\n4. 문서 정확성 검증",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "모든 도메인 엔티티의 member 필드를 owner로 리네이밍",
        "description": "Todo, Category, Challenge 등 모든 도메인 엔티티의 member 필드명을 owner로 변경하고, 관련된 getter/setter, repository 쿼리, 서비스 로직, 테스트 코드를 모두 수정합니다. 이 작업은 권한 시스템 구현 전에 완료되어야 합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "**중요: 이 리팩토링은 권한 시스템(Task 11) 구현 전에 반드시 완료되어야 합니다.**\n\n1. 엔티티 필드 리네이밍:\n   - Todo.java: @ManyToOne private Member member → Member owner\n   - Category.java: @ManyToOne private Member member → Member owner\n   - Challenge.java: @ManyToOne private Member member → Member owner\n   - ChallengeParticipation.java: 필요시 member → owner\n\n2. Getter/Setter 메서드 변경:\n   ```java\n   // 변경 전\n   public Member getMember() { return member; }\n   public void setMember(Member member) { this.member = member; }\n   \n   // 변경 후\n   public Member getOwner() { return owner; }\n   public void setOwner(Member owner) { this.owner = owner; }\n   ```\n\n3. Repository 쿼리 수정:\n   - JPQL: \"SELECT t FROM Todo t WHERE t.member = :member\" → \"t.owner = :owner\"\n   - @Query 어노테이션 파라미터: @Param(\"member\") → @Param(\"owner\")\n   - 메서드명: findByMember() → findByOwner()\n   - Specification: root.get(\"member\") → root.get(\"owner\")\n\n4. 서비스 레이어 수정:\n   - todo.setMember(currentMember) → todo.setOwner(currentMember)\n   - todo.getMember().getId() → todo.getOwner().getId()\n   - 권한 검증 로직의 member 참조를 owner로 변경\n\n5. DTO 및 Mapper 수정:\n   - ResponseDto의 member 필드 → owner\n   - MapStruct @Mapping 어노테이션 수정\n\n6. 테스트 코드 수정:\n   - 모든 테스트에서 member 관련 assertion을 owner로 변경\n   - Mock 객체 설정 시 member → owner\n   - 테스트 데이터 빌더 패턴의 withMember() → withOwner()\n\n7. 데이터베이스 마이그레이션:\n   - Flyway 스크립트: ALTER TABLE todo RENAME COLUMN member_id TO owner_id;\n   - 모든 테이블에 대해 동일하게 적용\n\n**권한 시스템과의 연관성:**\n- Task 11에서 구현할 isOwn() 메서드가 owner 필드를 참조하므로 이 리팩토링이 선행되어야 함\n- 일관된 네이밍으로 권한 검증 로직의 가독성 향상",
        "testStrategy": "1. 엔티티 단위 테스트:\n   - 각 엔티티의 owner getter/setter 동작 확인\n   - null owner 처리 테스트\n\n2. Repository 계층 테스트:\n   - findByOwner() 메서드 정상 동작 확인\n   - JPQL 쿼리의 owner 조건 검증\n   - 데이터베이스 실제 쿼리 실행 확인\n\n3. 서비스 계층 통합 테스트:\n   - 소유자 기반 조회 로직 검증\n   - 권한 검증 로직의 owner 체크 확인\n   - 트랜잭션 내 owner 변경 테스트\n\n4. 컨트롤러 통합 테스트:\n   - API 응답의 owner 필드 확인\n   - 소유자 필터링 API 동작 검증\n\n5. 전체 테스트 스위트 실행:\n   - mvn test 실행하여 모든 테스트 통과 확인\n   - 테스트 커버리지 유지 확인\n   - 리네이밍 누락 여부 검색 (grep -r \"member\" 실행)\n\n6. 회귀 테스트:\n   - 리팩토링 후 기존 기능이 정상 동작하는지 확인\n   - 권한 시스템 구현을 위한 기반이 마련되었는지 검증",
        "subtasks": [
          {
            "id": 1,
            "title": "도메인 엔티티의 member 필드를 owner로 리네이밍",
            "description": "Todo, Category, Challenge, ChallengeParticipation 엔티티의 member 필드명을 owner로 변경하고 관련 getter/setter 메서드를 수정합니다.",
            "dependencies": [],
            "details": "- Todo.java: @ManyToOne private Member member → Member owner\n- Category.java: @ManyToOne private Member member → Member owner\n- Challenge.java: @ManyToOne private Member member → Member owner\n- ChallengeParticipation.java: 필요시 member → owner\n- 각 엔티티의 getMember()/setMember() → getOwner()/setOwner()로 변경",
            "status": "done",
            "testStrategy": "엔티티 단위 테스트를 통해 owner getter/setter 동작 확인 및 null owner 처리 테스트"
          },
          {
            "id": 2,
            "title": "Repository 계층의 쿼리 메서드 수정",
            "description": "모든 Repository 클래스의 JPQL 쿼리, 메서드명, 파라미터명을 member에서 owner로 변경합니다.",
            "dependencies": [
              1
            ],
            "details": "- JPQL 쿼리: WHERE t.member = :member → WHERE t.owner = :owner\n- @Query 어노테이션 파라미터: @Param(\"member\") → @Param(\"owner\")\n- 메서드명: findByMember() → findByOwner()\n- Specification: root.get(\"member\") → root.get(\"owner\")\n- 모든 Repository 인터페이스 및 구현체 수정",
            "status": "done",
            "testStrategy": "findByOwner() 메서드 정상 동작 확인, JPQL 쿼리의 owner 조건 검증, 데이터베이스 실제 쿼리 실행 확인"
          },
          {
            "id": 3,
            "title": "서비스 계층의 비즈니스 로직 수정",
            "description": "모든 서비스 클래스에서 member 관련 로직을 owner로 변경하고 권한 검증 로직을 업데이트합니다.",
            "dependencies": [
              2
            ],
            "details": "- todo.setMember(currentMember) → todo.setOwner(currentMember)\n- todo.getMember().getId() → todo.getOwner().getId()\n- 권한 검증 로직의 member 참조를 owner로 변경\n- 모든 서비스 메서드에서 owner 관련 로직 수정",
            "status": "done",
            "testStrategy": "소유자 기반 조회 로직 검증, 권한 검증 로직의 owner 체크 확인, 트랜잭션 내 owner 변경 테스트"
          },
          {
            "id": 4,
            "title": "DTO 및 MapStruct 매핑 수정",
            "description": "ResponseDto, RequestDto의 member 필드를 owner로 변경하고 MapStruct 매핑 설정을 업데이트합니다.",
            "dependencies": [
              3
            ],
            "details": "- ResponseDto의 member 필드 → owner로 변경\n- RequestDto의 member 관련 필드 → owner로 변경\n- MapStruct @Mapping 어노테이션 수정\n- 모든 DTO 변환 로직 업데이트",
            "status": "done",
            "testStrategy": "DTO 변환 로직의 정확성 검증, MapStruct 매핑 동작 확인, 직렬화/역직렬화 테스트"
          },
          {
            "id": 5,
            "title": "테스트 코드 및 데이터베이스 마이그레이션",
            "description": "모든 테스트 코드의 member 참조를 owner로 변경하고 데이터베이스 컬럼명 변경을 위한 Flyway 마이그레이션 스크립트를 작성합니다.",
            "dependencies": [
              4
            ],
            "details": "- 모든 테스트에서 member 관련 assertion을 owner로 변경\n- Mock 객체 설정 시 member → owner\n- 테스트 데이터 빌더 패턴의 withMember() → withOwner()\n- Flyway 스크립트: ALTER TABLE todo RENAME COLUMN member_id TO owner_id;\n- 모든 테이블에 대해 동일하게 적용",
            "status": "done",
            "testStrategy": "모든 테스트 케이스 실행 및 통과 확인, 데이터베이스 마이그레이션 스크립트 검증, 기존 데이터 무결성 확인"
          }
        ]
      },
      {
        "id": 22,
        "title": "카테고리 Collaborator 시스템 구현",
        "description": "CategoryCollaborator 엔티티를 생성하고 카테고리의 협업자 관리 기능을 구현합니다. 협업자는 owner와 동일한 권한을 가지며 Todo 생성/수정/삭제/완료가 가능합니다. Collaborator가 되면 해당 카테고리의 모든 투두가 협업 투두로 표시되어 자신의 투두 목록에 나타납니다.",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "details": "1. CategoryCollaborator 엔티티 생성:\n```java\n@Entity\n@Table(name = \"category_collaborators\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class CategoryCollaborator extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"category_id\", nullable = false)\n    private Category category;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"member_id\", nullable = false)\n    private Member member;\n    \n    @Column(name = \"invited_at\", nullable = false)\n    private LocalDateTime invitedAt;\n    \n    @Column(name = \"accepted_at\")\n    private LocalDateTime acceptedAt;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false)\n    private CollaboratorStatus status = CollaboratorStatus.PENDING;\n    \n    // 생성자\n    public CategoryCollaborator(Category category, Member member) {\n        this.category = category;\n        this.member = member;\n        this.invitedAt = LocalDateTime.now();\n    }\n}\n\n@Getter\npublic enum CollaboratorStatus {\n    PENDING, ACCEPTED, REJECTED\n}\n```\n\n2. Todo 엔티티 수정 - 협업 투두 구분:\n```java\n@Entity\n@Table(name = \"todos\")\npublic class Todo extends BaseEntity {\n    // 기존 필드들...\n    \n    @Column(name = \"is_collaborative\")\n    private Boolean isCollaborative = false;\n    \n    // 투두 생성 시 협업 여부 자동 설정\n    @PrePersist\n    @PreUpdate\n    public void updateCollaborativeStatus() {\n        // 카테고리에 협업자가 있으면 협업 투두로 설정\n        if (this.category != null && !this.category.getCollaborators().isEmpty()) {\n            this.isCollaborative = true;\n        }\n    }\n    \n    // 협업 투두인지 확인\n    public boolean isCollaborativeTodo() {\n        return Boolean.TRUE.equals(isCollaborative);\n    }\n    \n    // 특정 사용자가 접근 가능한지 확인\n    public boolean isAccessibleBy(Member member) {\n        if (member == null) return false;\n        return this.category.canManage(member);\n    }\n}\n```\n\n3. Category 엔티티 수정:\n```java\n@Entity\npublic class Category extends BaseEntity {\n    // 기존 필드들...\n    \n    @OneToMany(mappedBy = \"category\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private Set<CategoryCollaborator> collaborators = new HashSet<>();\n    \n    // 협업자 확인 메서드\n    public boolean isCollaborator(Member member) {\n        if (member == null) return false;\n        if (this.owner.equals(member)) return true;\n        \n        return collaborators.stream()\n            .anyMatch(c -> c.getMember().equals(member) \n                && c.getStatus() == CollaboratorStatus.ACCEPTED);\n    }\n    \n    // 관리 권한 확인 메서드\n    public boolean canManage(Member member) {\n        return isCollaborator(member);\n    }\n    \n    // 협업자 추가\n    public void addCollaborator(Member member) {\n        if (this.owner.equals(member)) {\n            throw new IllegalArgumentException(\"Owner cannot be a collaborator\");\n        }\n        \n        CategoryCollaborator collaborator = new CategoryCollaborator(this, member);\n        this.collaborators.add(collaborator);\n        \n        // 기존 투두들을 협업 투두로 업데이트\n        this.todos.forEach(todo -> todo.setIsCollaborative(true));\n    }\n    \n    // 협업자 제거\n    public void removeCollaborator(Member member) {\n        collaborators.removeIf(c -> c.getMember().equals(member));\n        \n        // 협업자가 없으면 투두들을 비협업으로 변경\n        if (collaborators.isEmpty()) {\n            this.todos.forEach(todo -> todo.setIsCollaborative(false));\n        }\n    }\n    \n    // 수락된 협업자 목록 조회\n    public Set<Member> getAcceptedCollaborators() {\n        return collaborators.stream()\n            .filter(c -> c.getStatus() == CollaboratorStatus.ACCEPTED)\n            .map(CategoryCollaborator::getMember)\n            .collect(Collectors.toSet());\n    }\n}\n```\n\n4. CategoryCollaboratorRepository 구현:\n```java\n@Repository\npublic interface CategoryCollaboratorRepository extends JpaRepository<CategoryCollaborator, Long> {\n    Optional<CategoryCollaborator> findByCategoryAndMember(Category category, Member member);\n    \n    @Query(\"SELECT cc FROM CategoryCollaborator cc WHERE cc.member = :member AND cc.status = :status\")\n    List<CategoryCollaborator> findByMemberAndStatus(@Param(\"member\") Member member, @Param(\"status\") CollaboratorStatus status);\n    \n    @Query(\"SELECT COUNT(cc) FROM CategoryCollaborator cc WHERE cc.category = :category AND cc.status = 'ACCEPTED'\")\n    long countAcceptedCollaboratorsByCategory(@Param(\"category\") Category category);\n    \n    boolean existsByCategoryAndMemberAndStatus(Category category, Member member, CollaboratorStatus status);\n    \n    // 협업자인 카테고리의 ID 목록 조회\n    @Query(\"SELECT cc.category.id FROM CategoryCollaborator cc WHERE cc.member = :member AND cc.status = 'ACCEPTED'\")\n    List<Long> findCollaborativeCategoryIdsByMember(@Param(\"member\") Member member);\n}\n```\n\n5. TodoRepository 수정 - 협업 투두 포함 조회:\n```java\n@Repository\npublic interface TodoRepository extends JpaRepository<Todo, Long> {\n    // 내 투두 조회 (소유한 카테고리 + 협업하는 카테고리의 투두 모두 포함)\n    @Query(\"SELECT DISTINCT t FROM Todo t \" +\n           \"LEFT JOIN t.category c \" +\n           \"LEFT JOIN c.collaborators cc \" +\n           \"WHERE (c.owner = :member \" +\n           \"OR (cc.member = :member AND cc.status = 'ACCEPTED')) \" +\n           \"AND (:includeCompleted = true OR t.isCompleted = false) \" +\n           \"ORDER BY t.priority DESC, t.deadline ASC\")\n    List<Todo> findMyTodosIncludingCollaborative(\n        @Param(\"member\") Member member, \n        @Param(\"includeCompleted\") boolean includeCompleted\n    );\n    \n    // 협업 투두만 조회\n    @Query(\"SELECT t FROM Todo t \" +\n           \"JOIN t.category c \" +\n           \"JOIN c.collaborators cc \" +\n           \"WHERE cc.member = :member \" +\n           \"AND cc.status = 'ACCEPTED' \" +\n           \"AND t.isCollaborative = true \" +\n           \"ORDER BY t.priority DESC\")\n    List<Todo> findCollaborativeTodos(@Param(\"member\") Member member);\n}\n```\n\n6. CategoryService 수정:\n```java\n@Service\n@Transactional\npublic class CategoryService {\n    // 기존 메서드들...\n    \n    public void inviteCollaborator(Long categoryId, Long memberId, Member currentUser) {\n        Category category = categoryRepository.findById(categoryId)\n            .orElseThrow(() -> new EntityNotFoundException(\"Category not found\"));\n            \n        // owner만 협업자 초대 가능\n        if (!category.getOwner().equals(currentUser)) {\n            throw new UnauthorizedException(\"Only owner can invite collaborators\");\n        }\n        \n        Member invitee = memberRepository.findById(memberId)\n            .orElseThrow(() -> new EntityNotFoundException(\"Member not found\"));\n            \n        category.addCollaborator(invitee);\n        categoryRepository.save(category);\n    }\n    \n    public void acceptInvitation(Long categoryId, Member currentUser) {\n        CategoryCollaborator collaborator = collaboratorRepository\n            .findByCategoryAndMember(\n                categoryRepository.findById(categoryId).orElseThrow(),\n                currentUser\n            )\n            .orElseThrow(() -> new EntityNotFoundException(\"Invitation not found\"));\n            \n        collaborator.setStatus(CollaboratorStatus.ACCEPTED);\n        collaborator.setAcceptedAt(LocalDateTime.now());\n        collaboratorRepository.save(collaborator);\n    }\n    \n    // 협업 중인 카테고리 목록 조회\n    public List<CategoryDto> getCollaborativeCategories(Member member) {\n        List<Long> categoryIds = collaboratorRepository.findCollaborativeCategoryIdsByMember(member);\n        return categoryRepository.findAllById(categoryIds).stream()\n            .map(this::toDto)\n            .collect(Collectors.toList());\n    }\n}\n```\n\n7. TodoService 수정:\n```java\n@Service\npublic class TodoService {\n    // 투두 조회 - 협업 투두 포함\n    public List<TodoDto> getMyTodos(Member member, boolean includeCompleted) {\n        return todoRepository.findMyTodosIncludingCollaborative(member, includeCompleted)\n            .stream()\n            .map(todo -> {\n                TodoDto dto = toDto(todo);\n                // 협업 투두 표시\n                dto.setIsCollaborative(todo.isCollaborativeTodo());\n                // 협업 투두인 경우 카테고리 owner 정보 추가\n                if (todo.isCollaborativeTodo() && !todo.getCategory().getOwner().equals(member)) {\n                    dto.setCategoryOwnerName(todo.getCategory().getOwner().getNickname());\n                }\n                return dto;\n            })\n            .collect(Collectors.toList());\n    }\n    \n    public Todo createTodo(TodoCreateDto dto, Member member) {\n        Category category = categoryRepository.findById(dto.getCategoryId())\n            .orElseThrow(() -> new EntityNotFoundException(\"Category not found\"));\n            \n        // owner 또는 협업자만 Todo 생성 가능\n        if (!category.canManage(member)) {\n            throw new UnauthorizedException(\"You don't have permission to create todos in this category\");\n        }\n        \n        Todo todo = new Todo();\n        // ... 투두 생성 로직\n        todo.setIsCollaborative(!category.getCollaborators().isEmpty());\n        \n        return todoRepository.save(todo);\n    }\n    \n    public Todo updateTodo(Long todoId, TodoUpdateDto dto, Member member) {\n        Todo todo = todoRepository.findById(todoId)\n            .orElseThrow(() -> new EntityNotFoundException(\"Todo not found\"));\n            \n        // owner 또는 협업자만 수정 가능\n        if (!todo.getCategory().canManage(member)) {\n            throw new UnauthorizedException(\"You don't have permission to update this todo\");\n        }\n        \n        // Todo 수정 로직...\n    }\n}\n```\n\n8. TodoDto 수정:\n```java\n@Data\npublic class TodoDto {\n    // 기존 필드들...\n    \n    private Boolean isCollaborative;\n    private String categoryOwnerName; // 협업 투두인 경우 카테고리 소유자 이름\n    private List<String> collaboratorNames; // 협업자 목록\n}\n```\n\n9. 컨트롤러 엔드포인트 추가:\n```java\n@RestController\n@RequestMapping(\"/api/categories\")\npublic class CategoryController {\n    // 협업자 초대\n    @PostMapping(\"/{categoryId}/collaborators\")\n    public ResponseEntity<Void> inviteCollaborator(\n            @PathVariable Long categoryId,\n            @RequestBody CollaboratorInviteDto dto,\n            @AuthenticationPrincipal Member member) {\n        categoryService.inviteCollaborator(categoryId, dto.getMemberId(), member);\n        return ResponseEntity.ok().build();\n    }\n    \n    // 초대 수락\n    @PostMapping(\"/{categoryId}/collaborators/accept\")\n    public ResponseEntity<Void> acceptInvitation(\n            @PathVariable Long categoryId,\n            @AuthenticationPrincipal Member member) {\n        categoryService.acceptInvitation(categoryId, member);\n        return ResponseEntity.ok().build();\n    }\n    \n    // 협업 중인 카테고리 목록 조회\n    @GetMapping(\"/collaborative\")\n    public ResponseEntity<List<CategoryDto>> getCollaborativeCategories(\n            @AuthenticationPrincipal Member member) {\n        return ResponseEntity.ok(categoryService.getCollaborativeCategories(member));\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/todos\")\npublic class TodoController {\n    // 협업 투두만 조회\n    @GetMapping(\"/collaborative\")\n    public ResponseEntity<List<TodoDto>> getCollaborativeTodos(\n            @AuthenticationPrincipal Member member) {\n        return ResponseEntity.ok(todoService.getCollaborativeTodos(member));\n    }\n}\n```",
        "testStrategy": "1. 엔티티 단위 테스트:\n   - CategoryCollaborator 엔티티 생성 및 상태 변경 테스트\n   - Category.isCollaborator() 메서드 테스트 (owner, 협업자, 비협업자 케이스)\n   - Category.canManage() 메서드 테스트\n   - 협업자 추가/제거 메서드 테스트\n   - Todo.isCollaborativeTodo() 메서드 테스트\n   - Todo.updateCollaborativeStatus() 메서드 테스트\n   - Todo.isAccessibleBy() 메서드 테스트\n\n2. Repository 계층 테스트:\n   - 카테고리별 협업자 조회 테스트\n   - 멤버별 초대 목록 조회 테스트\n   - 협업자 수 카운트 쿼리 테스트\n   - 중복 협업자 방지 테스트\n   - findMyTodosIncludingCollaborative() 쿼리 테스트\n   - findCollaborativeTodos() 쿼리 테스트\n   - 협업 카테고리 ID 목록 조회 테스트\n\n3. 서비스 계층 통합 테스트:\n   - owner만 협업자 초대 가능 검증\n   - 협업자의 Todo CRUD 권한 검증\n   - 초대 수락/거절 프로세스 테스트\n   - owner는 협업자로 추가 불가 검증\n   - 협업자 추가 시 기존 투두 isCollaborative 플래그 업데이트 테스트\n   - 협업자 제거 시 투두 플래그 변경 테스트\n   - 협업 투두 조회 시 owner/collaborator 구분 테스트\n\n4. 컨트롤러 통합 테스트:\n   - 협업자 초대 API 테스트\n   - 초대 수락 API 테스트\n   - 비인가 사용자 접근 차단 테스트\n   - 협업자의 Todo 관련 API 접근 권한 테스트\n   - 협업 카테고리 목록 조회 API 테스트\n   - 협업 투두만 조회 API 테스트\n\n5. 시나리오 테스트:\n   - owner가 협업자 초대 → 협업자 수락 → 협업자가 Todo 생성/수정/삭제\n   - 협업자 제거 후 권한 상실 확인\n   - 여러 협업자가 동시에 같은 카테고리 수정 시 동시성 테스트\n   - 협업 투두가 각 협업자의 투두 목록에 표시되는지 확인\n   - 협업 투두 UI 구분 표시 테스트 (isCollaborative 플래그 확인)\n   - 협업자가 투두 생성 시 자동으로 isCollaborative=true 설정 확인",
        "subtasks": [
          {
            "id": 1,
            "title": "CategoryCollaborator 엔티티 및 Repository 구현",
            "description": "CategoryCollaborator 엔티티를 생성하고 협업자 상태 관리를 위한 enum과 Repository를 구현합니다",
            "dependencies": [],
            "details": "CategoryCollaborator 엔티티 생성 (id, category, member, invitedAt, acceptedAt, status 필드 포함), CollaboratorStatus enum 생성 (PENDING, ACCEPTED, REJECTED), CategoryCollaboratorRepository 인터페이스 구현 (findByCategoryAndMember, findByMemberAndStatus, countAcceptedCollaboratorsByCategory, existsByCategoryAndMemberAndStatus, findCollaborativeCategoryIdsByMember 메소드 포함), BaseEntity 상속으로 생성/수정 시간 자동 관리",
            "status": "done",
            "testStrategy": "엔티티 생성 테스트, Repository 메소드별 쿼리 동작 검증, 협업자 상태 변경 시나리오 테스트"
          },
          {
            "id": 2,
            "title": "Category 엔티티에 협업자 관리 기능 추가",
            "description": "Category 엔티티에 협업자 Set과 협업자 관리 메소드들을 추가하여 협업자 초대/제거 및 권한 확인 기능을 구현합니다",
            "dependencies": [],
            "details": "Category 엔티티에 Set<CategoryCollaborator> collaborators 필드 추가 (@OneToMany 매핑), isCollaborator(Member) 메소드 구현 (owner와 수락된 협업자 확인), canManage(Member) 메소드 구현, addCollaborator(Member) 메소드 구현 (owner 체크, 협업자 추가, 기존 투두 협업 설정), removeCollaborator(Member) 메소드 구현 (협업자 제거, 투두 협업 해제), getAcceptedCollaborators() 메소드 구현",
            "status": "done",
            "testStrategy": "협업자 추가/제거 테스트, owner를 협업자로 추가 시 예외 발생 테스트, 권한 확인 메소드 테스트"
          },
          {
            "id": 3,
            "title": "Todo 엔티티에 협업 투두 지원 기능 추가",
            "description": "Todo 엔티티에 협업 투두 구분을 위한 필드와 메소드를 추가하고, 협업 상태 자동 업데이트 로직을 구현합니다",
            "dependencies": [],
            "details": "Todo 엔티티에 Boolean isCollaborative 필드 추가 (기본값 false), updateCollaborativeStatus() 메소드 구현 (@PrePersist, @PreUpdate로 카테고리 협업자 존재 시 자동 설정), isCollaborativeTodo() 메소드 구현, isAccessibleBy(Member) 메소드 구현 (category.canManage() 활용), setIsCollaborative() setter 메소드 추가\n<info added on 2025-07-14T15:50:00.080Z>\n협업자 관리 API 추가: CategoryCollaboratorController 생성하여 협업자 초대(@PostMapping(\"/api/categories/{categoryId}/collaborators\"), 협업자 강제 퇴장(@DeleteMapping(\"/api/categories/{categoryId}/collaborators/{collaboratorId}\"), 협업자 자진 퇴장(@DeleteMapping(\"/api/categories/{categoryId}/collaborators/leave\"), 초대 거절(@DeleteMapping(\"/api/categories/{categoryId}/invitations/reject\") 엔드포인트 구현. 각 API는 권한 검증 후 CategoryCollaboratorService를 통해 처리. 협업자 퇴장 시 CategoryCollaborator 엔티티를 soft delete(deletedAt 설정)하고, 해당 협업자의 투두 목록에서 협업 투두가 즉시 사라지도록 TodoRepository의 쿼리 조건에 deletedAt IS NULL 추가. 협업 기록 보존을 위해 물리적 삭제는 하지 않음.\n</info added on 2025-07-14T15:50:00.080Z>",
            "status": "done",
            "testStrategy": "협업 상태 자동 업데이트 테스트, 접근 권한 확인 테스트, null 멤버 처리 테스트"
          },
          {
            "id": 4,
            "title": "TodoRepository 수정 및 협업 투두 조회 쿼리 구현",
            "description": "TodoRepository에 협업 투두를 포함한 조회 쿼리와 협업 투두만 조회하는 쿼리를 추가합니다",
            "dependencies": [],
            "details": "findMyTodosIncludingCollaborative() 메소드 구현 (소유 카테고리 + 협업 카테고리의 투두 조회, LEFT JOIN으로 카테고리와 협업자 연결, includeCompleted 파라미터로 완료 투두 포함 여부 제어), findCollaborativeTodos() 메소드 구현 (협업 투두만 조회, ACCEPTED 상태 협업자 필터링, isCollaborative=true 조건 추가)",
            "status": "done",
            "testStrategy": "소유자 투두만 있는 경우 테스트, 협업 투두만 있는 경우 테스트, 혼합된 경우 테스트, 완료 투두 포함/제외 테스트"
          },
          {
            "id": 5,
            "title": "Service 계층 구현 및 Controller 엔드포인트 추가",
            "description": "CategoryService와 TodoService에 협업자 관리 메소드를 추가하고, 관련 Controller 엔드포인트를 구현합니다",
            "dependencies": [],
            "details": "CategoryService: inviteCollaborator() 메소드 구현 (owner 권한 검증, 협업자 추가), acceptInvitation() 메소드 구현 (초대 수락 처리), getCollaborativeCategories() 메소드 구현; TodoService: getMyTodos() 수정 (협업 투두 포함, isCollaborative 플래그 설정, 협업 카테고리 owner 정보 추가), createTodo()/updateTodo() 수정 (canManage() 권한 검증); Controller: POST /api/categories/{id}/collaborators (초대), POST /api/categories/{id}/collaborators/accept (수락), GET /api/categories/collaborative (협업 카테고리 목록), GET /api/todos/collaborative (협업 투두 조회)",
            "status": "done",
            "testStrategy": "권한 검증 테스트, 협업자 초대/수락 시나리오 테스트, 협업 투두 CRUD 권한 테스트, API 통합 테스트"
          }
        ]
      },
      {
        "id": 23,
        "title": "챌린지 Leader(그룹장) 시스템 구현",
        "description": "ChallengeLeader 엔티티를 생성하고 챌린지 생성자와 Leader의 참여자 초대/추방 권한을 구현합니다. 일반 Participant는 ChallengeTodo 완료만 가능하도록 권한을 제한합니다.",
        "details": "1. ChallengeLeader 엔티티 생성:\n```java\n@Entity\n@Table(name = \"challenge_leaders\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class ChallengeLeader extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"challenge_id\", nullable = false)\n    private Challenge challenge;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"member_id\", nullable = false)\n    private Member member;\n    \n    @Column(nullable = false)\n    private LocalDateTime appointedAt;\n    \n    @Column\n    private String appointedBy; // 'CREATOR' or Leader의 ID\n    \n    @Builder\n    public ChallengeLeader(Challenge challenge, Member member, String appointedBy) {\n        this.challenge = challenge;\n        this.member = member;\n        this.appointedBy = appointedBy;\n        this.appointedAt = LocalDateTime.now();\n    }\n}\n```\n\n2. Challenge 엔티티 수정:\n```java\n@Entity\npublic class Challenge extends BaseEntity {\n    // 기존 필드들...\n    \n    @OneToMany(mappedBy = \"challenge\", cascade = CascadeType.ALL)\n    private List<ChallengeLeader> leaders = new ArrayList<>();\n    \n    // 권한 확인 메서드\n    public boolean isLeader(Member member) {\n        if (this.owner.equals(member)) {\n            return true;\n        }\n        return leaders.stream()\n            .anyMatch(leader -> leader.getMember().equals(member));\n    }\n    \n    public boolean canManageParticipants(Member member) {\n        return isLeader(member);\n    }\n    \n    // Leader 관리 메서드\n    public void addLeader(Member member, String appointedBy) {\n        if (isLeader(member)) {\n            throw new BusinessException(ErrorCode.ALREADY_LEADER);\n        }\n        ChallengeLeader leader = ChallengeLeader.builder()\n            .challenge(this)\n            .member(member)\n            .appointedBy(appointedBy)\n            .build();\n        this.leaders.add(leader);\n    }\n    \n    public void removeLeader(Member member) {\n        leaders.removeIf(leader -> leader.getMember().equals(member));\n    }\n}\n```\n\n3. ChallengeLeaderRepository 구현:\n```java\n@Repository\npublic interface ChallengeLeaderRepository extends JpaRepository<ChallengeLeader, Long> {\n    List<ChallengeLeader> findByChallengeId(Long challengeId);\n    Optional<ChallengeLeader> findByChallengeIdAndMemberId(Long challengeId, Long memberId);\n    boolean existsByChallengeIdAndMemberId(Long challengeId, Long memberId);\n    int countByChallengeId(Long challengeId);\n}\n```\n\n4. ChallengeService 권한 체크 로직 추가:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ChallengeService {\n    private final ChallengeRepository challengeRepository;\n    private final ChallengeLeaderRepository leaderRepository;\n    \n    @Transactional\n    public void inviteParticipant(Long challengeId, Long memberId, Member requester) {\n        Challenge challenge = challengeRepository.findById(challengeId)\n            .orElseThrow(() -> new BusinessException(ErrorCode.CHALLENGE_NOT_FOUND));\n            \n        if (!challenge.canManageParticipants(requester)) {\n            throw new BusinessException(ErrorCode.NO_PERMISSION_MANAGE_PARTICIPANTS);\n        }\n        \n        // 참여자 초대 로직...\n    }\n    \n    @Transactional\n    public void removeParticipant(Long challengeId, Long participantId, Member requester) {\n        Challenge challenge = challengeRepository.findById(challengeId)\n            .orElseThrow(() -> new BusinessException(ErrorCode.CHALLENGE_NOT_FOUND));\n            \n        if (!challenge.canManageParticipants(requester)) {\n            throw new BusinessException(ErrorCode.NO_PERMISSION_MANAGE_PARTICIPANTS);\n        }\n        \n        // 참여자 추방 로직...\n    }\n    \n    @Transactional\n    public void appointLeader(Long challengeId, Long memberId, Member requester) {\n        Challenge challenge = challengeRepository.findById(challengeId)\n            .orElseThrow(() -> new BusinessException(ErrorCode.CHALLENGE_NOT_FOUND));\n            \n        // Owner만 Leader 임명 가능\n        if (!challenge.getOwner().equals(requester)) {\n            throw new BusinessException(ErrorCode.ONLY_OWNER_CAN_APPOINT_LEADER);\n        }\n        \n        Member newLeader = memberRepository.findById(memberId)\n            .orElseThrow(() -> new BusinessException(ErrorCode.MEMBER_NOT_FOUND));\n            \n        challenge.addLeader(newLeader, requester.getId().toString());\n    }\n}\n```\n\n5. ChallengeTodoService 권한 체크:\n```java\n@Service\npublic class ChallengeTodoService {\n    @Transactional\n    public void completeTodo(Long todoId, Member member) {\n        ChallengeTodo todo = todoRepository.findById(todoId)\n            .orElseThrow(() -> new BusinessException(ErrorCode.TODO_NOT_FOUND));\n            \n        Challenge challenge = todo.getChallenge();\n        \n        // 참여자인지 확인 (Leader도 참여자에 포함)\n        if (!participationRepository.existsByChallengeIdAndMemberId(challenge.getId(), member.getId())) {\n            throw new BusinessException(ErrorCode.NOT_CHALLENGE_PARTICIPANT);\n        }\n        \n        // Todo 완료 처리...\n    }\n}\n```\n\n6. 데이터베이스 마이그레이션:\n```sql\nCREATE TABLE challenge_leaders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    challenge_id BIGINT NOT NULL,\n    member_id BIGINT NOT NULL,\n    appointed_at TIMESTAMP NOT NULL,\n    appointed_by VARCHAR(50),\n    created_at TIMESTAMP NOT NULL,\n    updated_at TIMESTAMP NOT NULL,\n    FOREIGN KEY (challenge_id) REFERENCES challenges(id),\n    FOREIGN KEY (member_id) REFERENCES members(id),\n    UNIQUE KEY uk_challenge_member (challenge_id, member_id)\n);\n```",
        "testStrategy": "1. 엔티티 단위 테스트:\n   - ChallengeLeader 엔티티 생성 및 필드 검증\n   - Challenge.isLeader() 메서드 테스트 (owner, leader, 일반 참여자 케이스)\n   - Challenge.canManageParticipants() 메서드 테스트\n   - Leader 추가/제거 메서드 테스트\n   - 중복 Leader 추가 시 예외 발생 테스트\n\n2. Repository 계층 테스트:\n   - 챌린지별 Leader 목록 조회 테스트\n   - 특정 멤버의 Leader 여부 확인 테스트\n   - Leader 수 카운트 쿼리 테스트\n\n3. 서비스 계층 통합 테스트:\n   - Owner의 참여자 초대/추방 권한 테스트\n   - Leader의 참여자 초대/추방 권한 테스트\n   - 일반 참여자의 권한 제한 테스트 (초대/추방 불가)\n   - Owner만 Leader 임명 가능 테스트\n   - 일반 참여자의 ChallengeTodo 완료 가능 테스트\n\n4. 컨트롤러 통합 테스트:\n   - API 엔드포인트별 권한 검증 테스트\n   - 403 Forbidden 응답 검증\n   - Leader 임명 API 테스트\n\n5. 시나리오 테스트:\n   - Owner가 챌린지 생성 → Leader 임명 → Leader가 참여자 초대 → 일반 참여자가 Todo 완료\n   - Leader 권한 박탈 후 참여자 관리 불가 확인\n   - 다중 Leader 시나리오 테스트",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "투두 조회 시스템 개선 - 협업 투두와 챌린지 투두 구분",
        "description": "Todo 엔티티에 collaborativeCategory 필드를 추가하여 협업 카테고리를 표시하고, TodoService에서 내 투두 조회 시 소유자와 협업자 투두를 모두 포함하도록 개선합니다. ChallengeTodo는 별도 API로 분리합니다.",
        "details": "1. Todo 엔티티 수정:\n```java\n@Entity\n@Table(name = \"todos\")\npublic class Todo extends BaseEntity {\n    // 기존 필드들...\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"collaborative_category_id\")\n    private Category collaborativeCategory;\n    \n    @Column(name = \"is_collaborative\")\n    private Boolean isCollaborative = false;\n    \n    // 협업 투두인지 확인\n    public boolean isCollaborativeTodo() {\n        return collaborativeCategory != null && isCollaborative;\n    }\n    \n    // 소유자 확인 (owner 또는 협업자)\n    public boolean isAccessibleBy(Member member) {\n        if (this.owner.equals(member)) {\n            return true;\n        }\n        if (isCollaborativeTodo() && collaborativeCategory.isCollaborator(member)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n2. TodoRepository 쿼리 수정:\n```java\n@Repository\npublic interface TodoRepository extends JpaRepository<Todo, Long> {\n    // 내 투두 조회 (소유자 + 협업자)\n    @Query(\"SELECT DISTINCT t FROM Todo t \" +\n           \"LEFT JOIN t.collaborativeCategory cc \" +\n           \"LEFT JOIN cc.collaborators c \" +\n           \"WHERE (t.owner = :member OR \" +\n           \"(t.isCollaborative = true AND c.member = :member)) \" +\n           \"AND t.deletedAt IS NULL \" +\n           \"ORDER BY t.createdAt DESC\")\n    Page<Todo> findMyTodos(@Param(\"member\") Member member, Pageable pageable);\n    \n    // 특정 카테고리의 투두 조회\n    @Query(\"SELECT t FROM Todo t \" +\n           \"WHERE t.category = :category \" +\n           \"AND t.deletedAt IS NULL \" +\n           \"ORDER BY t.priority DESC, t.createdAt DESC\")\n    List<Todo> findByCategoryOrderByPriority(@Param(\"category\") Category category);\n    \n    // 협업 카테고리의 투두 조회\n    @Query(\"SELECT t FROM Todo t \" +\n           \"WHERE t.collaborativeCategory = :category \" +\n           \"AND t.isCollaborative = true \" +\n           \"AND t.deletedAt IS NULL \" +\n           \"ORDER BY t.priority DESC, t.createdAt DESC\")\n    List<Todo> findByCollaborativeCategory(@Param(\"category\") Category category);\n}\n```\n\n3. TodoService 수정:\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class TodoService {\n    private final TodoRepository todoRepository;\n    private final CategoryRepository categoryRepository;\n    private final ChallengeRepository challengeRepository;\n    \n    // 내 투두 조회 (협업 투두 포함)\n    public Page<TodoResponseDto> getMyTodos(Member member, Pageable pageable) {\n        Page<Todo> todos = todoRepository.findMyTodos(member, pageable);\n        return todos.map(todo -> TodoResponseDto.of(todo, \n            todo.isCollaborativeTodo() ? \"COLLABORATIVE\" : \"PERSONAL\"));\n    }\n    \n    // 투두 생성 (협업 카테고리 지원)\n    public TodoResponseDto createTodo(Member member, TodoCreateDto dto) {\n        Todo todo = new Todo();\n        todo.setOwner(member);\n        todo.setTitle(dto.getTitle());\n        todo.setDescription(dto.getDescription());\n        \n        if (dto.getCategoryId() != null) {\n            Category category = categoryRepository.findById(dto.getCategoryId())\n                .orElseThrow(() -> new CategoryNotFoundException(dto.getCategoryId()));\n            \n            // 협업 카테고리인 경우\n            if (dto.isCollaborative() && category.isCollaborator(member)) {\n                todo.setCollaborativeCategory(category);\n                todo.setIsCollaborative(true);\n            } else if (category.getOwner().equals(member)) {\n                todo.setCategory(category);\n            } else {\n                throw new UnauthorizedException(\"카테고리에 대한 권한이 없습니다.\");\n            }\n        }\n        \n        return TodoResponseDto.of(todoRepository.save(todo));\n    }\n    \n    // 투두 수정 권한 검증\n    public void updateTodo(Member member, Long todoId, TodoUpdateDto dto) {\n        Todo todo = todoRepository.findById(todoId)\n            .orElseThrow(() -> new TodoNotFoundException(todoId));\n        \n        if (!todo.isAccessibleBy(member)) {\n            throw new UnauthorizedException(\"투두 수정 권한이 없습니다.\");\n        }\n        \n        // 투두 업데이트 로직...\n    }\n}\n```\n\n4. ChallengeTodoService 분리:\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class ChallengeTodoService {\n    private final ChallengeTodoRepository challengeTodoRepository;\n    private final ChallengeRepository challengeRepository;\n    \n    // 챌린지 투두 조회 (별도 API)\n    public Page<ChallengeTodoResponseDto> getMyChallengeTodos(Member member, Pageable pageable) {\n        return challengeTodoRepository.findByParticipantMember(member, pageable)\n            .map(ChallengeTodoResponseDto::of);\n    }\n    \n    // 특정 챌린지의 투두 조회\n    public List<ChallengeTodoResponseDto> getChallengeTodos(Member member, Long challengeId) {\n        Challenge challenge = challengeRepository.findById(challengeId)\n            .orElseThrow(() -> new ChallengeNotFoundException(challengeId));\n        \n        if (!challenge.isParticipant(member)) {\n            throw new UnauthorizedException(\"챌린지 참여자가 아닙니다.\");\n        }\n        \n        return challengeTodoRepository.findByChallengeOrderByCreatedAt(challenge)\n            .stream()\n            .map(ChallengeTodoResponseDto::of)\n            .collect(Collectors.toList());\n    }\n}\n```\n\n5. Controller 엔드포인트 분리:\n```java\n@RestController\n@RequestMapping(\"/api/todos\")\n@RequiredArgsConstructor\npublic class TodoController {\n    private final TodoService todoService;\n    \n    @GetMapping(\"/my\")\n    public ResponseEntity<Page<TodoResponseDto>> getMyTodos(\n            @AuthenticationPrincipal Member member,\n            Pageable pageable) {\n        return ResponseEntity.ok(todoService.getMyTodos(member, pageable));\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/challenge-todos\")\n@RequiredArgsConstructor\npublic class ChallengeTodoController {\n    private final ChallengeTodoService challengeTodoService;\n    \n    @GetMapping(\"/my\")\n    public ResponseEntity<Page<ChallengeTodoResponseDto>> getMyChallengeTodos(\n            @AuthenticationPrincipal Member member,\n            Pageable pageable) {\n        return ResponseEntity.ok(challengeTodoService.getMyChallengeTodos(member, pageable));\n    }\n}\n```\n\n6. DTO 수정:\n```java\n@Getter\n@Builder\npublic class TodoResponseDto {\n    private Long id;\n    private String title;\n    private String description;\n    private String status;\n    private String priority;\n    private LocalDateTime dueDate;\n    private String todoType; // PERSONAL, COLLABORATIVE\n    private Long categoryId;\n    private String categoryName;\n    private Long collaborativeCategoryId;\n    private String collaborativeCategoryName;\n    private Long ownerId;\n    private String ownerName;\n    \n    public static TodoResponseDto of(Todo todo, String todoType) {\n        return TodoResponseDto.builder()\n            .id(todo.getId())\n            .title(todo.getTitle())\n            .todoType(todoType)\n            .categoryId(todo.getCategory() != null ? todo.getCategory().getId() : null)\n            .collaborativeCategoryId(todo.getCollaborativeCategory() != null ? \n                todo.getCollaborativeCategory().getId() : null)\n            // ... 나머지 필드 매핑\n            .build();\n    }\n}\n```",
        "testStrategy": "1. 엔티티 단위 테스트:\n   - Todo.isCollaborativeTodo() 메서드 테스트\n   - Todo.isAccessibleBy() 메서드 테스트 (owner, collaborator, 외부인 케이스)\n   - collaborativeCategory 필드 null 처리 테스트\n\n2. Repository 계층 테스트:\n   - findMyTodos() 쿼리 테스트:\n     * owner인 투두만 있는 경우\n     * collaborator인 투두만 있는 경우\n     * owner와 collaborator 투두가 섞여있는 경우\n     * 삭제된 투두 제외 확인\n   - findByCollaborativeCategory() 테스트\n   - 페이징 처리 정확성 검증\n\n3. 서비스 계층 통합 테스트:\n   - 협업 카테고리로 투두 생성 테스트\n   - 일반 카테고리로 투두 생성 테스트\n   - 권한 없는 카테고리로 투두 생성 시 예외 발생 테스트\n   - 협업자가 협업 투두 수정 가능 테스트\n   - 비협업자가 협업 투두 수정 시 예외 발생 테스트\n\n4. ChallengeTodoService 분리 테스트:\n   - 챌린지 투두 조회가 일반 투두 조회와 분리되었는지 확인\n   - 챌린지 참여자만 챌린지 투두 조회 가능 테스트\n   - 챌린지 비참여자 접근 시 예외 발생 테스트\n\n5. API 엔드포인트 테스트:\n   - GET /api/todos/my 응답에 협업 투두 포함 확인\n   - GET /api/challenge-todos/my 별도 엔드포인트 동작 확인\n   - todoType 필드가 올바르게 설정되는지 검증\n   - 응답 DTO에 협업 카테고리 정보 포함 확인\n\n6. 성능 테스트:\n   - 대량의 협업 투두가 있을 때 조회 성능\n   - N+1 쿼리 문제 발생 여부 확인\n   - 인덱스 최적화 필요성 검토",
        "status": "pending",
        "dependencies": [
          22
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Notification System 구현 - 시스템 알림 및 알림 이력 관리",
        "description": "협업자 초대, 초대 수락/거절, 챌린지 참여 요청 등의 이벤트를 알림으로 저장하는 Notification 엔티티와 NotificationHistory를 구현합니다. 읽음/안읽음 상태 관리와 알림 타입별 분류를 포함하며, 실시간 알림(SSE/WebSocket)을 위한 확장 가능한 구조로 설계합니다.",
        "details": "1. Notification 엔티티 생성:\n```java\n@Entity\n@Table(name = \"notifications\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class Notification extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"recipient_id\", nullable = false)\n    private Member recipient; // 알림 수신자\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"sender_id\")\n    private Member sender; // 알림 발신자 (시스템 알림의 경우 null)\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private NotificationType type;\n    \n    @Column(nullable = false)\n    private String title;\n    \n    @Column(columnDefinition = \"TEXT\")\n    private String content;\n    \n    @Column(name = \"is_read\", nullable = false)\n    private Boolean isRead = false;\n    \n    @Column(name = \"related_entity_id\")\n    private Long relatedEntityId; // 관련 엔티티 ID (category_id, challenge_id 등)\n    \n    @Column(name = \"related_entity_type\")\n    private String relatedEntityType; // CATEGORY, CHALLENGE, TODO 등\n    \n    @Column(columnDefinition = \"TEXT\")\n    private String actionUrl; // 알림 클릭 시 이동할 URL\n    \n    @Column(name = \"expires_at\")\n    private LocalDateTime expiresAt; // 알림 만료 시간\n    \n    // 읽음 처리\n    public void markAsRead() {\n        this.isRead = true;\n    }\n    \n    // 만료 여부 확인\n    public boolean isExpired() {\n        return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);\n    }\n}\n```\n\n2. NotificationType enum 정의:\n```java\npublic enum NotificationType {\n    // 협업 관련\n    CATEGORY_INVITATION(\"카테고리 협업 초대\"),\n    CATEGORY_INVITATION_ACCEPTED(\"카테고리 협업 수락\"),\n    CATEGORY_INVITATION_REJECTED(\"카테고리 협업 거절\"),\n    CATEGORY_COLLABORATOR_REMOVED(\"카테고리 협업자 제거\"),\n    \n    // 챌린지 관련\n    CHALLENGE_INVITATION(\"챌린지 참여 초대\"),\n    CHALLENGE_INVITATION_ACCEPTED(\"챌린지 참여 수락\"),\n    CHALLENGE_INVITATION_REJECTED(\"챌린지 참여 거절\"),\n    CHALLENGE_PARTICIPANT_REMOVED(\"챌린지 참여자 제거\"),\n    CHALLENGE_LEADER_ASSIGNED(\"챌린지 리더 임명\"),\n    CHALLENGE_TODO_COMPLETED(\"챌린지 투두 완료\"),\n    \n    // 시스템 알림\n    SYSTEM_ANNOUNCEMENT(\"시스템 공지\"),\n    SYSTEM_MAINTENANCE(\"시스템 점검\");\n    \n    private final String description;\n    \n    NotificationType(String description) {\n        this.description = description;\n    }\n}\n```\n\n3. NotificationHistory 엔티티 생성:\n```java\n@Entity\n@Table(name = \"notification_history\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class NotificationHistory extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"notification_id\", nullable = false)\n    private Notification notification;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private NotificationAction action;\n    \n    @Column(name = \"action_timestamp\", nullable = false)\n    private LocalDateTime actionTimestamp;\n    \n    @Column(columnDefinition = \"TEXT\")\n    private String additionalInfo;\n}\n\npublic enum NotificationAction {\n    CREATED(\"생성됨\"),\n    READ(\"읽음\"),\n    DELETED(\"삭제됨\"),\n    EXPIRED(\"만료됨\");\n    \n    private final String description;\n    \n    NotificationAction(String description) {\n        this.description = description;\n    }\n}\n```\n\n4. NotificationRepository 구현:\n```java\n@Repository\npublic interface NotificationRepository extends JpaRepository<Notification, Long> {\n    // 사용자별 알림 조회\n    @Query(\"SELECT n FROM Notification n WHERE n.recipient.id = :recipientId \" +\n           \"AND (n.expiresAt IS NULL OR n.expiresAt > :now) \" +\n           \"ORDER BY n.createdAt DESC\")\n    Page<Notification> findActiveByRecipientId(@Param(\"recipientId\") Long recipientId, \n                                               @Param(\"now\") LocalDateTime now, \n                                               Pageable pageable);\n    \n    // 읽지 않은 알림 개수\n    @Query(\"SELECT COUNT(n) FROM Notification n WHERE n.recipient.id = :recipientId \" +\n           \"AND n.isRead = false AND (n.expiresAt IS NULL OR n.expiresAt > :now)\")\n    long countUnreadByRecipientId(@Param(\"recipientId\") Long recipientId, \n                                  @Param(\"now\") LocalDateTime now);\n    \n    // 타입별 알림 조회\n    List<Notification> findByRecipientIdAndType(Long recipientId, NotificationType type);\n    \n    // 관련 엔티티별 알림 조회\n    List<Notification> findByRelatedEntityIdAndRelatedEntityType(Long entityId, String entityType);\n    \n    // 만료된 알림 조회\n    @Query(\"SELECT n FROM Notification n WHERE n.expiresAt < :now AND n.isRead = false\")\n    List<Notification> findExpiredNotifications(@Param(\"now\") LocalDateTime now);\n}\n```\n\n5. NotificationService 구현:\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class NotificationService {\n    private final NotificationRepository notificationRepository;\n    private final NotificationHistoryRepository historyRepository;\n    private final ApplicationEventPublisher eventPublisher;\n    \n    // 알림 생성\n    public Notification createNotification(NotificationCreateDto dto) {\n        Notification notification = new Notification();\n        notification.setRecipient(dto.getRecipient());\n        notification.setSender(dto.getSender());\n        notification.setType(dto.getType());\n        notification.setTitle(dto.getTitle());\n        notification.setContent(dto.getContent());\n        notification.setRelatedEntityId(dto.getRelatedEntityId());\n        notification.setRelatedEntityType(dto.getRelatedEntityType());\n        notification.setActionUrl(dto.getActionUrl());\n        notification.setExpiresAt(dto.getExpiresAt());\n        \n        notification = notificationRepository.save(notification);\n        \n        // 히스토리 기록\n        createHistory(notification, NotificationAction.CREATED);\n        \n        // 실시간 알림 이벤트 발행 (향후 SSE/WebSocket 연동)\n        eventPublisher.publishEvent(new NotificationCreatedEvent(notification));\n        \n        return notification;\n    }\n    \n    // 알림 읽음 처리\n    public void markAsRead(Long notificationId, Long memberId) {\n        Notification notification = notificationRepository.findById(notificationId)\n            .orElseThrow(() -> new NotFoundException(\"알림을 찾을 수 없습니다.\"));\n        \n        if (!notification.getRecipient().getId().equals(memberId)) {\n            throw new UnauthorizedException(\"알림 읽기 권한이 없습니다.\");\n        }\n        \n        if (!notification.isRead()) {\n            notification.markAsRead();\n            notificationRepository.save(notification);\n            createHistory(notification, NotificationAction.READ);\n        }\n    }\n    \n    // 알림 일괄 읽음 처리\n    public void markAllAsRead(Long memberId) {\n        List<Notification> unreadNotifications = notificationRepository\n            .findActiveByRecipientId(memberId, LocalDateTime.now(), PageRequest.of(0, 1000))\n            .getContent()\n            .stream()\n            .filter(n -> !n.isRead())\n            .collect(Collectors.toList());\n        \n        unreadNotifications.forEach(n -> {\n            n.markAsRead();\n            createHistory(n, NotificationAction.READ);\n        });\n        \n        notificationRepository.saveAll(unreadNotifications);\n    }\n    \n    // 알림 목록 조회\n    public Page<NotificationDto> getNotifications(Long memberId, Pageable pageable) {\n        return notificationRepository.findActiveByRecipientId(memberId, LocalDateTime.now(), pageable)\n            .map(this::toDto);\n    }\n    \n    // 읽지 않은 알림 개수 조회\n    public long getUnreadCount(Long memberId) {\n        return notificationRepository.countUnreadByRecipientId(memberId, LocalDateTime.now());\n    }\n    \n    // 협업 초대 알림 생성\n    public void createCollaborationInviteNotification(Member recipient, Member sender, Category category) {\n        NotificationCreateDto dto = NotificationCreateDto.builder()\n            .recipient(recipient)\n            .sender(sender)\n            .type(NotificationType.CATEGORY_INVITATION)\n            .title(\"카테고리 협업 초대\")\n            .content(String.format(\"%s님이 '%s' 카테고리의 협업자로 초대했습니다.\", \n                sender.getName(), category.getName()))\n            .relatedEntityId(category.getId())\n            .relatedEntityType(\"CATEGORY\")\n            .actionUrl(\"/categories/\" + category.getId() + \"/invitation\")\n            .expiresAt(LocalDateTime.now().plusDays(7)) // 7일 후 만료\n            .build();\n        \n        createNotification(dto);\n    }\n    \n    // 챌린지 초대 알림 생성\n    public void createChallengeInviteNotification(Member recipient, Member sender, Challenge challenge) {\n        NotificationCreateDto dto = NotificationCreateDto.builder()\n            .recipient(recipient)\n            .sender(sender)\n            .type(NotificationType.CHALLENGE_INVITATION)\n            .title(\"챌린지 참여 초대\")\n            .content(String.format(\"%s님이 '%s' 챌린지에 초대했습니다.\", \n                sender.getName(), challenge.getTitle()))\n            .relatedEntityId(challenge.getId())\n            .relatedEntityType(\"CHALLENGE\")\n            .actionUrl(\"/challenges/\" + challenge.getId() + \"/invitation\")\n            .expiresAt(LocalDateTime.now().plusDays(3)) // 3일 후 만료\n            .build();\n        \n        createNotification(dto);\n    }\n    \n    // 히스토리 생성\n    private void createHistory(Notification notification, NotificationAction action) {\n        NotificationHistory history = new NotificationHistory();\n        history.setNotification(notification);\n        history.setAction(action);\n        history.setActionTimestamp(LocalDateTime.now());\n        historyRepository.save(history);\n    }\n    \n    // 만료된 알림 처리 (스케줄러에서 호출)\n    @Scheduled(cron = \"0 0 * * * *\") // 매시간 실행\n    public void processExpiredNotifications() {\n        List<Notification> expiredNotifications = notificationRepository\n            .findExpiredNotifications(LocalDateTime.now());\n        \n        expiredNotifications.forEach(n -> {\n            createHistory(n, NotificationAction.EXPIRED);\n        });\n    }\n}\n```\n\n6. 실시간 알림 이벤트 (향후 SSE/WebSocket 연동용):\n```java\n@Getter\n@AllArgsConstructor\npublic class NotificationCreatedEvent {\n    private final Notification notification;\n    private final LocalDateTime timestamp = LocalDateTime.now();\n}\n\n@Component\n@RequiredArgsConstructor\npublic class NotificationEventListener {\n    // 향후 SSE/WebSocket 구현 시 사용\n    @EventListener\n    public void handleNotificationCreated(NotificationCreatedEvent event) {\n        // SSE 또는 WebSocket을 통해 클라이언트에 실시간 전송\n        // 현재는 로깅만 수행\n        log.info(\"New notification created for user {}: {}\", \n            event.getNotification().getRecipient().getId(),\n            event.getNotification().getTitle());\n    }\n}\n```\n\n7. NotificationController 구현:\n```java\n@RestController\n@RequestMapping(\"/api/notifications\")\n@RequiredArgsConstructor\n@Tag(name = \"Notification\", description = \"알림 관리 API\")\npublic class NotificationController {\n    private final NotificationService notificationService;\n    \n    @GetMapping\n    @Operation(summary = \"알림 목록 조회\")\n    public ResponseEntity<Page<NotificationDto>> getNotifications(\n            @AuthenticationPrincipal Long memberId,\n            @PageableDefault(size = 20, sort = \"createdAt,desc\") Pageable pageable) {\n        return ResponseEntity.ok(notificationService.getNotifications(memberId, pageable));\n    }\n    \n    @GetMapping(\"/unread-count\")\n    @Operation(summary = \"읽지 않은 알림 개수 조회\")\n    public ResponseEntity<Map<String, Long>> getUnreadCount(\n            @AuthenticationPrincipal Long memberId) {\n        long count = notificationService.getUnreadCount(memberId);\n        return ResponseEntity.ok(Map.of(\"unreadCount\", count));\n    }\n    \n    @PutMapping(\"/{id}/read\")\n    @Operation(summary = \"알림 읽음 처리\")\n    public ResponseEntity<Void> markAsRead(\n            @PathVariable Long id,\n            @AuthenticationPrincipal Long memberId) {\n        notificationService.markAsRead(id, memberId);\n        return ResponseEntity.ok().build();\n    }\n    \n    @PutMapping(\"/read-all\")\n    @Operation(summary = \"모든 알림 읽음 처리\")\n    public ResponseEntity<Void> markAllAsRead(\n            @AuthenticationPrincipal Long memberId) {\n        notificationService.markAllAsRead(memberId);\n        return ResponseEntity.ok().build();\n    }\n}\n```",
        "testStrategy": "1. 엔티티 단위 테스트:\n   - Notification 엔티티 생성 및 필드 검증\n   - markAsRead() 메서드 동작 확인\n   - isExpired() 메서드 테스트 (만료 시간 null, 과거, 미래 케이스)\n   - NotificationHistory 엔티티 생성 및 관계 설정 테스트\n\n2. Repository 계층 테스트:\n   - findActiveByRecipientId() 쿼리 테스트:\n     * 만료되지 않은 알림만 조회되는지 확인\n     * 페이징 및 정렬 동작 확인\n   - countUnreadByRecipientId() 쿼리 테스트:\n     * 읽지 않은 알림 개수 정확성\n     * 만료된 알림 제외 확인\n   - findExpiredNotifications() 쿼리 테스트\n   - 타입별, 관련 엔티티별 조회 테스트\n\n3. 서비스 계층 통합 테스트:\n   - 알림 생성 테스트:\n     * 정상 생성 확인\n     * 히스토리 자동 생성 확인\n     * 이벤트 발행 확인\n   - 읽음 처리 테스트:\n     * 개별 읽음 처리\n     * 일괄 읽음 처리\n     * 권한 없는 사용자 접근 시 예외 발생\n   - 협업/챌린지 초대 알림 생성 테스트:\n     * 적절한 내용과 만료 시간 설정 확인\n     * actionUrl 정확성 검증\n\n4. 컨트롤러 통합 테스트:\n   - GET /api/notifications 엔드포인트 테스트\n   - GET /api/notifications/unread-count 테스트\n   - PUT /api/notifications/{id}/read 테스트\n   - PUT /api/notifications/read-all 테스트\n   - 인증 없는 요청 시 401 응답 확인\n\n5. 동시성 테스트:\n   - 동일 알림에 대한 동시 읽음 처리\n   - 대량 알림 생성 시 성능 테스트\n\n6. 스케줄러 테스트:\n   - processExpiredNotifications() 메서드 동작 확인\n   - 만료된 알림 히스토리 기록 검증",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-14T14:54:00.173Z",
      "updated": "2025-07-15T03:10:46.576Z",
      "description": "Tasks for master context"
    }
  }
}